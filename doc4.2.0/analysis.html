
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>15. Analysis &#8212; ESPResSo 4.2.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/blockquotes.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/toggleprompt.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="16. Input and Output" href="io.html" />
    <link rel="prev" title="14. Electrokinetics" href="ek.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="analysis">
<span id="id1"></span><h1><span class="section-number">15. </span>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h1>
<p><em>ESPResSo</em> provides two concepts of system analysis:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#direct-analysis-routines"><span class="std std-ref">Direct analysis routines</span></a>: The <a class="reference internal" href="espressomd.html#module-espressomd.analyze" title="espressomd.analyze"><code class="xref py py-mod docutils literal notranslate"><span class="pre">espressomd.analyze</span></code></a> module provides
online-calculation of specialized local and global observables with
calculation and data accumulation performed in the core.</p></li>
<li><p><a class="reference internal" href="#observables-framework"><span class="std std-ref">Observables framework</span></a>: This provides a more flexible concept of
in-core analysis, where a certain observable (<a class="reference internal" href="#available-observables"><span class="std std-ref">Available observables</span></a>),
a rule for data accumulation (<a class="reference internal" href="#accumulators"><span class="std std-ref">Accumulators</span></a>) and/or correlation (<a class="reference internal" href="#correlations"><span class="std std-ref">Correlations</span></a>) can be defined.</p></li>
</ul>
<div class="section" id="direct-analysis-routines">
<span id="id2"></span><h2><span class="section-number">15.1. </span>Direct analysis routines<a class="headerlink" href="#direct-analysis-routines" title="Permalink to this headline">¶</a></h2>
<p>The direct analysis commands only take into account the current configuration of the system.
Available commands are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#energies"><span class="std std-ref">Energies</span></a></p></li>
<li><p><a class="reference internal" href="#pressure"><span class="std std-ref">Pressure</span></a></p></li>
<li><p><a class="reference internal" href="#pressure-tensor"><span class="std std-ref">Pressure Tensor</span></a></p></li>
<li><p><a class="reference internal" href="#momentum-of-the-system"><span class="std std-ref">Momentum of the System</span></a></p></li>
<li><p><a class="reference internal" href="#minimal-distances-between-particles"><span class="std std-ref">Minimal distances between particles</span></a></p></li>
<li><p><a class="reference internal" href="#particles-in-the-neighborhood"><span class="std std-ref">Particles in the neighborhood</span></a></p></li>
<li><p><a class="reference internal" href="#particle-distribution"><span class="std std-ref">Particle distribution</span></a></p></li>
<li><p><a class="reference internal" href="#structure-factor"><span class="std std-ref">Structure factor</span></a></p></li>
<li><p><a class="reference internal" href="#center-of-mass"><span class="std std-ref">Center of mass</span></a></p></li>
<li><p><a class="reference internal" href="#moment-of-inertia-matrix"><span class="std std-ref">Moment of inertia matrix</span></a></p></li>
<li><p><a class="reference internal" href="#gyration-tensor"><span class="std std-ref">Gyration tensor</span></a></p></li>
</ul>
<div class="section" id="energies">
<span id="id3"></span><h3><span class="section-number">15.1.1. </span>Energies<a class="headerlink" href="#energies" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.energy" title="espressomd.analyze.Analysis.energy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.energy()</span></code></a></p>
<p>Returns the energies of the system.
The different energetic contributions to the total energy can also be obtained (kinetic, bonded, non-bonded, Coulomb).</p>
<p>For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">energy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">energy</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">energy</span><span class="p">[</span><span class="s2">&quot;kinetic&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">energy</span><span class="p">[</span><span class="s2">&quot;bonded&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">energy</span><span class="p">[</span><span class="s2">&quot;non_bonded&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="momentum-of-the-system">
<span id="id4"></span><h3><span class="section-number">15.1.2. </span>Momentum of the System<a class="headerlink" href="#momentum-of-the-system" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.linear_momentum" title="espressomd.analyze.Analysis.linear_momentum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.linear_momentum()</span></code></a></p>
<p>This command returns the total linear momentum of the particles and the
lattice-Boltzmann (LB) fluid, if one exists. Giving the optional
parameters either causes the command to ignore the contribution of LB or
of the particles.</p>
</div>
<div class="section" id="minimal-distances-between-particles">
<span id="id5"></span><h3><span class="section-number">15.1.3. </span>Minimal distances between particles<a class="headerlink" href="#minimal-distances-between-particles" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.min_dist" title="espressomd.analyze.Analysis.min_dist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.min_dist()</span></code></a>
Returns the minimal distance between all particles in the system.</p>
<p>When used with type-lists as arguments, then the minimal distance between particles of only those types is determined.</p>
<p>For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">espressomd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">i</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">system</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">min_dist</span><span class="p">()</span>
<span class="go">1.0</span>
</pre></div>
</div>
</div>
<div class="section" id="particles-in-the-neighborhood">
<span id="id6"></span><h3><span class="section-number">15.1.4. </span>Particles in the neighborhood<a class="headerlink" href="#particles-in-the-neighborhood" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.nbhood" title="espressomd.analyze.Analysis.nbhood"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.nbhood()</span></code></a></p>
<p>Returns a list of the ids of particles that fall within a given radius of a target position.
For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ids</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">nbhood</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">system</span><span class="o">.</span><span class="n">box_l</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">r_catch</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="particle-distribution">
<span id="id7"></span><h3><span class="section-number">15.1.5. </span>Particle distribution<a class="headerlink" href="#particle-distribution" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.distribution" title="espressomd.analyze.Analysis.distribution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.distribution()</span></code></a></p>
<p>Returns the distance distribution of particles
(probability of finding a particle of a certain type at a specified distance around
a particle of another specified type, disregarding the fact that a spherical shell of a
larger radius covers a larger volume).
The distance is defined as the <em>minimal</em> distance between a particle of one group to any of the other
group.</p>
<p>Two arrays are returned corresponding to the normalized distribution and the bins midpoints, for example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">i</span> <span class="o">*</span> <span class="n">system</span><span class="o">.</span><span class="n">box_l</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">distribution</span><span class="p">(</span><span class="n">type_list_a</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">type_list_b</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                                           <span class="n">r_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">r_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
<span class="go">[ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="go">[ 1.  0.  0.  0.  0.  0.  0.  0.  0.  0.]</span>
</pre></div>
</div>
</div>
<div class="section" id="structure-factor">
<span id="id8"></span><h3><span class="section-number">15.1.6. </span>Structure factor<a class="headerlink" href="#structure-factor" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.structure_factor" title="espressomd.analyze.Analysis.structure_factor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.structure_factor()</span></code></a></p>
<p>Calculate the structure factor for given types.</p>
<p>Returns the spherically averaged structure factor <span class="math notranslate nohighlight">\(S(q)\)</span> of
particles specified in <code class="docutils literal notranslate"><span class="pre">sf_types</span></code>. <span class="math notranslate nohighlight">\(S(q)\)</span> is calculated for all possible
wave vectors <span class="math notranslate nohighlight">\(\frac{2\pi}{L} \leq q \leq \frac{2\pi}{L}\)</span> up to <code class="docutils literal notranslate"><span class="pre">sf_order</span></code>.</p>
</div>
<div class="section" id="center-of-mass">
<span id="id9"></span><h3><span class="section-number">15.1.7. </span>Center of mass<a class="headerlink" href="#center-of-mass" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.center_of_mass" title="espressomd.analyze.Analysis.center_of_mass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.center_of_mass()</span></code></a></p>
<p>Returns the center of mass of particles of the given type given by <code class="docutils literal notranslate"><span class="pre">part_type</span></code>.</p>
</div>
<div class="section" id="moment-of-inertia-matrix">
<span id="id10"></span><h3><span class="section-number">15.1.8. </span>Moment of inertia matrix<a class="headerlink" href="#moment-of-inertia-matrix" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.moment_of_inertia_matrix" title="espressomd.analyze.Analysis.moment_of_inertia_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.moment_of_inertia_matrix()</span></code></a></p>
<p>Returns the 3x3 moment of inertia matrix for particles of a given type.</p>
</div>
<div class="section" id="gyration-tensor">
<span id="id11"></span><h3><span class="section-number">15.1.9. </span>Gyration tensor<a class="headerlink" href="#gyration-tensor" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.gyration_tensor" title="espressomd.analyze.Analysis.gyration_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.gyration_tensor()</span></code></a></p>
<p>Analyze the gyration tensor of particles of a given type, or of all particles in the system if no type is given. Returns a dictionary containing the squared radius of gyration, three shape descriptors (asphericity, acylindricity, and relative shape anisotropy), eigenvalues of the gyration tensor and their corresponding eigenvectors. The eigenvalues are sorted in descending order.</p>
</div>
<div class="section" id="pressure">
<span id="id12"></span><h3><span class="section-number">15.1.10. </span>Pressure<a class="headerlink" href="#pressure" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.pressure" title="espressomd.analyze.Analysis.pressure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.pressure()</span></code></a></p>
<p>Computes the instantaneous virial pressure for an isotropic and homogeneous system. It
returns all the contributions to the total pressure as well as the total pressure (see <a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.pressure" title="espressomd.analyze.Analysis.pressure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.pressure()</span></code></a>).</p>
<p>The instantaneous pressure is calculated (if there are no electrostatic interactions)
by the volume averaged, direction averaged instantaneous virial pressure</p>
<div class="math notranslate nohighlight" id="equation-eqptens">
<span class="eqno">(1)<a class="headerlink" href="#equation-eqptens" title="Permalink to this equation">¶</a></span>\[p = \frac{2E_{\text{kinetic}}}{Vf} + \frac{\sum_{j&gt;i} {F_{ij}r_{ij}}}{3V}\]</div>
<p>where <span class="math notranslate nohighlight">\(f=3\)</span> is the number of translational degrees of freedom of
each particle, <span class="math notranslate nohighlight">\(V\)</span> is the volume of the system,
<span class="math notranslate nohighlight">\(E_{\text{kinetic}}\)</span> is the kinetic energy, <span class="math notranslate nohighlight">\(F_{ij}\)</span> the force
between particles i and j, and <span class="math notranslate nohighlight">\(r_{ij}\)</span> is the distance between
them. The kinetic energy divided by the degrees of freedom is</p>
<div class="math notranslate nohighlight">
\[\frac{2E_{\text{kinetic}}}{f} = \frac{1}{3}\sum_{i} {m_{i}v_{i}^{2}}.\]</div>
<p>Note that Equation <a class="reference internal" href="#equation-eqptens">(1)</a> can only be applied to pair potentials and
central forces. Description of how contributions from other interactions
are calculated is beyond the scope of this manual. Three body potentials
are implemented following the procedure in
Ref. <span id="id13">[<a class="reference internal" href="bibliography.html#id89" title="A. P. Thompson, S. J. Plimpton, and W. Mattson. General formulation of pressure and stress tensor for arbitrary many-body interaction potentials under periodic boundary conditions. The Journal of Chemical Physics, 131(15):154107, 2009. doi:10.1063/1.3245303.">Thompson <em>et al.</em>, 2009</a>]</span>. A different formula is used to
calculate contribution from electrostatic interactions. For
electrostatic interactions in P3M, the <span class="math notranslate nohighlight">\(k\)</span>-space contribution is implemented according to <span id="id14">[<a class="reference internal" href="bibliography.html#id38" title="Ulrich Essmann, Lalith Perera, Max L. Berkowitz, Tom Darden, Hsing Lee, and Lee G. Pedersen. A smooth particle mesh Ewald method. The Journal of Chemical Physics, 103(19):8577–8593, 1995. doi:10.1063/1.470117.">Essmann <em>et al.</em>, 1995</a>]</span>.
The implementation of the Coulomb P3M pressure is tested against LAMMPS.</p>
<p>Four-body dihedral potentials are not included. Except of
<code class="docutils literal notranslate"><span class="pre">VIRTUAL_SITES_RELATIVE</span></code> constraints all other
constraints of any kind are not currently accounted for in the pressure
calculations. The pressure is no longer correct, e.g., when particles
are confined to a plane.</p>
<p>Note: The different contributions which are returned are the summands that arise from force splitting <span class="math notranslate nohighlight">\(\vec{F}_{i,j}={\vec{F}_{i,j}}_\text{bonded}+{\vec{F}_{i,j}}_\text{nonbonded}+...\)</span> in the virial pressure formula. Later when the user calculates the ensemble average via e.g. <span class="math notranslate nohighlight">\(\langle p \rangle \approx 1/N \sum_{i=1}^N p_i\)</span> however the ensemble average with all interactions present is performed. That means the contributions are not easy to interpret! Those are the contributions to the pressure in a system where all interactions are present and therefore in a coupled system.</p>
</div>
<div class="section" id="pressure-tensor">
<span id="id15"></span><h3><span class="section-number">15.1.11. </span>Pressure Tensor<a class="headerlink" href="#pressure-tensor" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.pressure_tensor" title="espressomd.analyze.Analysis.pressure_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.pressure_tensor()</span></code></a></p>
<p>Computes the volume averaged instantaneous pressure tensor of the system with options which are
described by in <a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.pressure_tensor" title="espressomd.analyze.Analysis.pressure_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.pressure_tensor()</span></code></a>.
In general do only use it for (on average) homogeneous systems. For inhomogeneous systems you need to use the local pressure tensor.</p>
<p>The instantaneous virial pressure tensor is calculated by</p>
<div class="math notranslate nohighlight">
\[p_{(k,l)} = \frac{\sum_{i} {m_{i}v_{i}^{(k)}v_{i}^{(l)}}}{V} + \frac{\sum_{j&gt;i}{F_{ij}^{(k)}r_{ij}^{(l)}}}{V}\]</div>
<p>where the notation is the same as for the pressure. The superscripts <span class="math notranslate nohighlight">\(k\)</span>
and <span class="math notranslate nohighlight">\(l\)</span> correspond to the components in the tensors and vectors.</p>
<p>If electrostatic interactions are present then also the coulombic parts of the pressure tensor need to be calculated. If P3M is present, then the instantaneous pressure tensor is added to the above equation in accordance with <span id="id16">[<a class="reference internal" href="bibliography.html#id38" title="Ulrich Essmann, Lalith Perera, Max L. Berkowitz, Tom Darden, Hsing Lee, and Lee G. Pedersen. A smooth particle mesh Ewald method. The Journal of Chemical Physics, 103(19):8577–8593, 1995. doi:10.1063/1.470117.">Essmann <em>et al.</em>, 1995</a>]</span> :</p>
<div class="math notranslate nohighlight">
\[p^\text{Coulomb, P3M}_{(k,l)} =p^\text{Coulomb, P3M, dir}_{(k,l)} + p^\text{Coulomb, P3M, rec}_{(k,l)},\]</div>
<p>where the first summand is the short ranged part and the second summand is the long ranged part.</p>
<p>The short ranged part is given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}p^\text{Coulomb, P3M, dir}_{(k,l)}= \frac{1}{4\pi \varepsilon_0 \varepsilon_r} \frac{1}{2V} \sum_{\vec{n}}^* \sum_{i,j=1}^N q_i q_j \left( \frac{ \mathrm{erfc}(\beta |\vec{r}_j-\vec{r}_i+\vec{n}|)}{|\vec{r}_j-\vec{r}_i+\vec{n}|^3} + \\ \frac{2\beta \pi^{-1/2} \exp(-(\beta |\vec{r}_j-\vec{r}_i+\vec{n}|)^2)}{|\vec{r}_j-\vec{r}_i+\vec{n}|^2} \right) (\vec{r}_j-\vec{r}_i+\vec{n})_k (\vec{r}_j-\vec{r}_i+\vec{n})_l,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta\)</span> is the P3M splitting parameter, <span class="math notranslate nohighlight">\(\vec{n}\)</span> identifies the periodic images, the asterisk denotes that terms with <span class="math notranslate nohighlight">\(\vec{n}=\vec{0}\)</span> and i=j are omitted.
The long ranged (k-space) part is given by:</p>
<div class="math notranslate nohighlight">
\[p^\text{Coulomb, P3M, rec}_{(k,l)}= \frac{1}{4\pi \varepsilon_0 \varepsilon_r} \frac{1}{2 \pi V^2} \sum_{\vec{k} \neq \vec{0}} \frac{\exp(-\pi^2 \vec{k}^2/\beta^2)}{\vec{k}^2} |S(\vec{k})|^2 \cdot (\delta_{k,l}-2\frac{1+\pi^2\vec{k}^2/\beta^2}{\vec{k}^2} \vec{k}_k \vec{k}_l),\]</div>
<p>where <span class="math notranslate nohighlight">\(S(\vec{k})\)</span> is the Fourier transformed charge density. Compared to Essmann we do not have the contribution <span class="math notranslate nohighlight">\(p^\text{corr}_{k,l}\)</span> since we want to calculate the pressure that arises from all particles in the system.</p>
<p>Note: The different contributions which are returned are the summands that arise from force splitting <span class="math notranslate nohighlight">\(\vec{F}_{i,j}={\vec{F}_{i,j}}_\text{bonded}+{\vec{F}_{i,j}}_\text{nonbonded}+...\)</span> in the virial pressure tensor formula.
Later when the user calculates the pressure tensor via <span class="math notranslate nohighlight">\(\langle p_{(k,l)}\rangle  \approx 1/N \sum_{i=1}^N p_{k,l}\)</span> however the ensemble average with all interactions present is performed.
That means the contributions are not easy to interpret! Those are the contributions to the pressure in a system where all interactions are present and therefore in a coupled system.</p>
<p>Note that the angular velocities of the particles are not included in
the calculation of the pressure tensor.</p>
</div>
<div class="section" id="chains">
<span id="id17"></span><h3><span class="section-number">15.1.12. </span>Chains<a class="headerlink" href="#chains" title="Permalink to this headline">¶</a></h3>
<p>All analysis functions in this section require the topology of the chains to be set correctly.
The above set of functions is designed to facilitate analysis of molecules.
Molecules are expected to be a group of particles comprising a contiguous range of particle IDs.
Each molecule is a set of consecutively numbered particles and all molecules are supposed to consist of the same number of particles.</p>
<p>Some functions in this group require that the particles constituting a molecule are connected into
linear chains (particle <span class="math notranslate nohighlight">\(n\)</span> is connected to <span class="math notranslate nohighlight">\(n+1\)</span> and so on)
while others are applicable to molecules of whatever topology.</p>
<div class="section" id="end-to-end-distance">
<span id="id18"></span><h4><span class="section-number">15.1.12.1. </span>End-to-end distance<a class="headerlink" href="#end-to-end-distance" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.calc_re" title="espressomd.analyze.Analysis.calc_re"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.calc_re()</span></code></a></p>
<p>Returns the quadratic end-to-end-distance and its root averaged over all chains.</p>
</div>
<div class="section" id="radius-of-gyration">
<span id="id19"></span><h4><span class="section-number">15.1.12.2. </span>Radius of gyration<a class="headerlink" href="#radius-of-gyration" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.calc_rg" title="espressomd.analyze.Analysis.calc_rg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.calc_rg()</span></code></a></p>
<p>Returns the radius of gyration averaged over all chains.
It is a radius of a sphere, which would have the same moment of inertia as the
molecule, defined as</p>
<div class="math notranslate nohighlight">
\[\label{eq:Rg}
R_{\mathrm G}^2 = \frac{1}{N} \sum\limits_{i=1}^{N} \left(\vec r_i - \vec r_{\mathrm{cm}}\right)^2\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(\vec r_i\)</span> are position vectors of individual particles
constituting a molecule and <span class="math notranslate nohighlight">\(\vec r_{\mathrm{cm}}\)</span> is the position
vector of its center of mass. The sum runs over all <span class="math notranslate nohighlight">\(N\)</span> particles
comprising the molecule. For more information see any polymer science
book, e.g. <span id="id20">[<a class="reference internal" href="bibliography.html#id77" title="Michael Rubinstein and Ralph H. Colby. Polymer Physics. Oxford University Press, Oxford, UK, 2003.">Rubinstein and Colby, 2003</a>]</span>.</p>
</div>
<div class="section" id="hydrodynamic-radius">
<span id="id21"></span><h4><span class="section-number">15.1.12.3. </span>Hydrodynamic radius<a class="headerlink" href="#hydrodynamic-radius" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.calc_rh" title="espressomd.analyze.Analysis.calc_rh"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.analyze.Analysis.calc_rh()</span></code></a></p>
<p>Returns the hydrodynamic radius averaged over all chains.
The following formula is used for the computation:</p>
<div class="math notranslate nohighlight">
\[\label{eq:Rh}
\frac{1}{R_{\mathrm H}} = \frac{2}{N(N-1)} \sum\limits_{i=1}^{N} \sum\limits_{j&lt;i}^{N} \frac{1}{|\vec r_i - \vec r_j|}\,,\]</div>
<p>The above-mentioned formula is only valid under certain assumptions.
For more information, see chapter 4 and equation 4.102 in <span id="id22">[<a class="reference internal" href="bibliography.html#id31" title="Masao Doi and Samuel Frederick Edwards. The Theory of Polymer Dynamics. Clarendon Press: Oxford, 1986. ISBN 9780198519768.">Doi and Edwards, 1986</a>]</span>.
Note that the hydrodynamic radius is sometimes defined in a similar fashion
but with a denominator of <span class="math notranslate nohighlight">\(N^2\)</span> instead of <span class="math notranslate nohighlight">\(N(N-1)\)</span> in the prefactor.
Both versions are equivalent in the <span class="math notranslate nohighlight">\(N\rightarrow \infty\)</span> limit but give
numerically different values for finite polymers.</p>
</div>
</div>
</div>
<div class="section" id="observables-framework">
<span id="id23"></span><h2><span class="section-number">15.2. </span>Observables framework<a class="headerlink" href="#observables-framework" title="Permalink to this headline">¶</a></h2>
<p>Observables extract properties of the particles and the LB fluid and
return either the raw data or a statistic derived from them.
Correlators and accumulators provide functionality to collect and
process the output of observables automatically throughout the course
of the simulation.</p>
<p>The Observables framework is progressively replacing the Analysis framework.
This is motivated by the fact, that sometimes it is desirable that the
analysis functions do more than just return a value to the scripting
interface. For some observables it is desirable to be sampled every few
integration steps. In addition, it should be possible to pass the
observable values to other functions which compute history-dependent
quantities, such as correlation functions. All this should be done
without the need to interrupt the integration by passing the control to
the script level and back, which produces a significant overhead when
performed too often.</p>
<p>Some observables in the core have their corresponding counterparts in
the <a class="reference internal" href="espressomd.html#module-espressomd.analyze" title="espressomd.analyze"><code class="xref py py-mod docutils literal notranslate"><span class="pre">espressomd.analyze</span></code></a> module. However, only the core-observables
can be used on the fly with the toolbox of accumulators and correlators.</p>
<p>The first step of the core analysis is to create an observable.
An observable in the sense of the core analysis can be considered as a
rule how to compute a certain set of numbers from a given state of the
system or a rule how to collect data from other observables. Any
observable is represented as a single array of double values in the core.
Any more complex shape (tensor, complex number, …) must be compatible to this
prerequisite. Every observable however documents the storage order and returns
a reshaped numpy array.</p>
<p>The observables can be used in parallel simulations. However,
not all observables carry out their calculations in parallel.
Instead, the entire particle configuration is collected on the head node,
and the calculations are carried out there.
This is only performance-relevant if the number of processor cores is large
and/or interactions are calculated very frequently.</p>
<div class="section" id="using-observables">
<span id="id24"></span><h3><span class="section-number">15.2.1. </span>Using observables<a class="headerlink" href="#using-observables" title="Permalink to this headline">¶</a></h3>
<p>The observables are represented as Python classes derived from
<a class="reference internal" href="espressomd.html#espressomd.observables.Observable" title="espressomd.observables.Observable"><code class="xref py py-class docutils literal notranslate"><span class="pre">espressomd.observables.Observable</span></code></a>. They are contained in
the <code class="docutils literal notranslate"><span class="pre">espressomd.observables</span></code> module. An observable is instantiated as
follows</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd.observables</span>
<span class="n">part_pos</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">observables</span><span class="o">.</span><span class="n">ParticlePositions</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<p>Here, the keyword argument <code class="docutils literal notranslate"><span class="pre">ids</span></code> specifies the ids of the particles,
which the observable should take into account.</p>
<p>The current value of an observable can be obtained using its
<a class="reference internal" href="espressomd.html#espressomd.observables.Observable.calculate" title="espressomd.observables.Observable.calculate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calculate()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">part_pos</span><span class="o">.</span><span class="n">calculate</span><span class="p">())</span>
</pre></div>
</div>
<p>Profile observables have additional methods
<a class="reference internal" href="espressomd.html#espressomd.observables.ProfileObservable.bin_centers" title="espressomd.observables.ProfileObservable.bin_centers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bin_centers()</span></code></a> and
<a class="reference internal" href="espressomd.html#espressomd.observables.ProfileObservable.bin_edges" title="espressomd.observables.ProfileObservable.bin_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bin_edges()</span></code></a> to facilitate
plotting of histogram slices with functions that require either bin centers
or bin edges for the axes. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">espressomd</span>
<span class="kn">import</span> <span class="nn">espressomd.observables</span>

<span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">])</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">])</span>

<span class="c1"># histogram in Cartesian coordinates</span>
<span class="n">density_profile</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">observables</span><span class="o">.</span><span class="n">DensityProfile</span><span class="p">(</span>
    <span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">id</span><span class="p">],</span>
    <span class="n">n_x_bins</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">min_x</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_x</span><span class="o">=</span><span class="mf">9.0</span><span class="p">,</span>
    <span class="n">n_y_bins</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">min_y</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_y</span><span class="o">=</span><span class="mf">9.0</span><span class="p">,</span>
    <span class="n">n_z_bins</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">min_z</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">max_z</span><span class="o">=</span><span class="mf">8.0</span><span class="p">)</span>
<span class="n">obs_data</span> <span class="o">=</span> <span class="n">density_profile</span><span class="o">.</span><span class="n">calculate</span><span class="p">()</span>
<span class="n">obs_bins</span> <span class="o">=</span> <span class="n">density_profile</span><span class="o">.</span><span class="n">bin_centers</span><span class="p">()</span>

<span class="c1"># 1D slice: requires bin centers</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">obs_bins</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">obs_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 2D slice: requires extent</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">obs_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>
           <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">density_profile</span><span class="o">.</span><span class="n">min_x</span><span class="p">,</span> <span class="n">density_profile</span><span class="o">.</span><span class="n">max_x</span><span class="p">,</span>
                   <span class="n">density_profile</span><span class="o">.</span><span class="n">min_y</span><span class="p">,</span> <span class="n">density_profile</span><span class="o">.</span><span class="n">max_y</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Observables based on cylindrical coordinates are also available.
They require special parameters if the cylindrical coordinate system is non-standard,
e.g. if you want the origin of the cylindrical coordinates to be at a special location
of the box or if you want to make use of symmetries along an axis that is not parallel to the z-axis.
For this purpose, use <a class="reference internal" href="espressomd.html#espressomd.math.CylindricalTransformationParameters" title="espressomd.math.CylindricalTransformationParameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">espressomd.math.CylindricalTransformationParameters</span></code></a>
to create a consistent set of the parameters needed. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd.math</span>

<span class="c1"># shifted and rotated cylindrical coordinates</span>
<span class="n">cyl_transform_params</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">CylindricalTransformationParameters</span><span class="p">(</span>
    <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">orientation</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="c1"># histogram in cylindrical coordinates</span>
<span class="n">density_profile</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">observables</span><span class="o">.</span><span class="n">CylindricalDensityProfile</span><span class="p">(</span>
    <span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">id</span><span class="p">],</span>
    <span class="n">transform_params</span> <span class="o">=</span> <span class="n">cyl_transform_params</span><span class="p">,</span>
    <span class="n">n_r_bins</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">min_r</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_r</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
    <span class="n">n_phi_bins</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">min_phi</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">max_phi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
    <span class="n">n_z_bins</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">min_z</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">max_z</span><span class="o">=</span><span class="mf">8.0</span><span class="p">)</span>
<span class="n">obs_data</span> <span class="o">=</span> <span class="n">density_profile</span><span class="o">.</span><span class="n">calculate</span><span class="p">()</span>
<span class="n">obs_bins</span> <span class="o">=</span> <span class="n">density_profile</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">()</span>

<span class="c1"># 2D slice: requires bin edges</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="s1">&#39;True&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">obs_bins</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">obs_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">obs_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="available-observables">
<span id="id25"></span><h3><span class="section-number">15.2.2. </span>Available observables<a class="headerlink" href="#available-observables" title="Permalink to this headline">¶</a></h3>
<p>The following list contains some of the available observables. You can find
documentation for all available observables in <a class="reference internal" href="espressomd.html#module-espressomd.observables" title="espressomd.observables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">espressomd.observables</span></code></a>.</p>
<ul class="simple">
<li><dl class="simple">
<dt>Observables working on a given set of particles:</dt><dd><ul>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ParticlePositions" title="espressomd.observables.ParticlePositions"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticlePositions</span></code></a>: Positions of the particles</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ParticleVelocities" title="espressomd.observables.ParticleVelocities"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleVelocities</span></code></a>: Velocities of the particles</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ParticleForces" title="espressomd.observables.ParticleForces"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleForces</span></code></a>: Forces on the particles</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ParticleBodyVelocities" title="espressomd.observables.ParticleBodyVelocities"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleBodyVelocities</span></code></a>: The particles’ velocities in their respective body-fixed frames (as per their orientation in space stored in their quaternions).</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ParticleAngularVelocities" title="espressomd.observables.ParticleAngularVelocities"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleAngularVelocities</span></code></a>: The particles’ angular velocities in the space-fixed frame</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ParticleBodyAngularVelocities" title="espressomd.observables.ParticleBodyAngularVelocities"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleBodyAngularVelocities</span></code></a>: As above, but in the particles’ body-fixed frame.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Observables working on a given set of particles and returning reduced quantities:</dt><dd><ul>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.DipoleMoment" title="espressomd.observables.DipoleMoment"><code class="xref py py-class docutils literal notranslate"><span class="pre">DipoleMoment</span></code></a>: Total electric dipole moment of the system obtained based on unfolded positions</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.MagneticDipoleMoment" title="espressomd.observables.MagneticDipoleMoment"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagneticDipoleMoment</span></code></a>: Total magnetic dipole moment of the system based on the <a class="reference internal" href="espressomd.html#espressomd.particle_data.ParticleHandle.dip" title="espressomd.particle_data.ParticleHandle.dip"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dip</span></code></a> property.</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ComPosition" title="espressomd.observables.ComPosition"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComPosition</span></code></a>: The system’s center of mass based on unfolded coordinates</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ComVelocity" title="espressomd.observables.ComVelocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComVelocity</span></code></a>: Velocity of the center of mass</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ParticleDistances" title="espressomd.observables.ParticleDistances"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleDistances</span></code></a>: Distances between particles on a polymer chain.</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.TotalForce" title="espressomd.observables.TotalForce"><code class="xref py py-class docutils literal notranslate"><span class="pre">TotalForce</span></code></a>: Sum of the forces on the particles</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.BondAngles" title="espressomd.observables.BondAngles"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondAngles</span></code></a>: Angles between bonds on a polymer chain.</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.BondDihedrals" title="espressomd.observables.BondDihedrals"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondDihedrals</span></code></a>: Dihedral angles between bond triples on a polymer chain.</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.CosPersistenceAngles" title="espressomd.observables.CosPersistenceAngles"><code class="xref py py-class docutils literal notranslate"><span class="pre">CosPersistenceAngles</span></code></a>: Cosine of angles between bonds. The <code class="docutils literal notranslate"><span class="pre">i</span></code>-th value in the result vector corresponds to the cosine of the angle between
bonds that are separated by <code class="docutils literal notranslate"><span class="pre">i</span></code> bonds. This observable might be useful for measuring the persistence length of a polymer.</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.RDF" title="espressomd.observables.RDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RDF</span></code></a>: Radial distribution function. Can be used on two different sets of particles.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Profile observables sampling the spatial profile of various quantities:</dt><dd><ul>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.DensityProfile" title="espressomd.observables.DensityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">DensityProfile</span></code></a></p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.FluxDensityProfile" title="espressomd.observables.FluxDensityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">FluxDensityProfile</span></code></a></p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.ForceDensityProfile" title="espressomd.observables.ForceDensityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForceDensityProfile</span></code></a></p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.LBVelocityProfile" title="espressomd.observables.LBVelocityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBVelocityProfile</span></code></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Observables sampling the cylindrical profile of various quantities:</dt><dd><ul>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.CylindricalDensityProfile" title="espressomd.observables.CylindricalDensityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">CylindricalDensityProfile</span></code></a></p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.CylindricalFluxDensityProfile" title="espressomd.observables.CylindricalFluxDensityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">CylindricalFluxDensityProfile</span></code></a></p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.CylindricalVelocityProfile" title="espressomd.observables.CylindricalVelocityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">CylindricalVelocityProfile</span></code></a></p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.CylindricalLBVelocityProfile" title="espressomd.observables.CylindricalLBVelocityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">CylindricalLBVelocityProfile</span></code></a></p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.CylindricalLBFluxDensityProfileAtParticlePositions" title="espressomd.observables.CylindricalLBFluxDensityProfileAtParticlePositions"><code class="xref py py-class docutils literal notranslate"><span class="pre">CylindricalLBFluxDensityProfileAtParticlePositions</span></code></a></p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.CylindricalLBVelocityProfileAtParticlePositions" title="espressomd.observables.CylindricalLBVelocityProfileAtParticlePositions"><code class="xref py py-class docutils literal notranslate"><span class="pre">CylindricalLBVelocityProfileAtParticlePositions</span></code></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>System-wide observables</dt><dd><ul>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.Energy" title="espressomd.observables.Energy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Energy</span></code></a>: Total energy (see <a class="reference internal" href="#energies"><span class="std std-ref">Energies</span></a>)</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.Pressure" title="espressomd.observables.Pressure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pressure</span></code></a>: Total scalar pressure (see <a class="reference internal" href="#pressure"><span class="std std-ref">Pressure</span></a>)</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.PressureTensor" title="espressomd.observables.PressureTensor"><code class="xref py py-class docutils literal notranslate"><span class="pre">PressureTensor</span></code></a>: Total pressure tensor (see <a class="reference internal" href="#pressure-tensor"><span class="std std-ref">Pressure Tensor</span></a>)</p></li>
<li><p><a class="reference internal" href="espressomd.html#espressomd.observables.DPDStress" title="espressomd.observables.DPDStress"><code class="xref py py-class docutils literal notranslate"><span class="pre">DPDStress</span></code></a></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="accumulators">
<span id="id26"></span><h3><span class="section-number">15.2.3. </span>Accumulators<a class="headerlink" href="#accumulators" title="Permalink to this headline">¶</a></h3>
<div class="section" id="time-series">
<span id="id27"></span><h4><span class="section-number">15.2.3.1. </span>Time series<a class="headerlink" href="#time-series" title="Permalink to this headline">¶</a></h4>
<p>In order to take snapshots of an observable,
<a class="reference internal" href="espressomd.html#espressomd.accumulators.TimeSeries" title="espressomd.accumulators.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">espressomd.accumulators.TimeSeries</span></code></a> can be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd</span>
<span class="kn">import</span> <span class="nn">espressomd.observables</span>
<span class="kn">import</span> <span class="nn">espressomd.accumulators</span>

<span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="n">system</span><span class="o">.</span><span class="n">cell_system</span><span class="o">.</span><span class="n">skin</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="n">system</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span> <span class="n">v</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">position_observable</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">observables</span><span class="o">.</span><span class="n">ParticlePositions</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>
<span class="n">accumulator</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">accumulators</span><span class="o">.</span><span class="n">TimeSeries</span><span class="p">(</span>
    <span class="n">obs</span><span class="o">=</span><span class="n">position_observable</span><span class="p">,</span> <span class="n">delta_N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">auto_update_accumulators</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">accumulator</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">accumulator</span><span class="o">.</span><span class="n">time_series</span><span class="p">())</span>
</pre></div>
</div>
<p>In the example above the automatic update of the accumulator is used. However,
it’s also possible to manually update the accumulator by calling
<a class="reference internal" href="espressomd.html#espressomd.accumulators.TimeSeries.update" title="espressomd.accumulators.TimeSeries.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.accumulators.TimeSeries.update()</span></code></a>.</p>
</div>
<div class="section" id="mean-variance-calculator">
<span id="id28"></span><h4><span class="section-number">15.2.3.2. </span>Mean-variance calculator<a class="headerlink" href="#mean-variance-calculator" title="Permalink to this headline">¶</a></h4>
<p>In order to calculate the running mean and variance of an observable,
<a class="reference internal" href="espressomd.html#espressomd.accumulators.MeanVarianceCalculator" title="espressomd.accumulators.MeanVarianceCalculator"><code class="xref py py-class docutils literal notranslate"><span class="pre">espressomd.accumulators.MeanVarianceCalculator</span></code></a> can be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd</span>
<span class="kn">import</span> <span class="nn">espressomd.observables</span>
<span class="kn">import</span> <span class="nn">espressomd.accumulators</span>

<span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="n">system</span><span class="o">.</span><span class="n">cell_system</span><span class="o">.</span><span class="n">skin</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="n">system</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span> <span class="n">v</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">position_observable</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">observables</span><span class="o">.</span><span class="n">ParticlePositions</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>
<span class="n">accumulator</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">accumulators</span><span class="o">.</span><span class="n">MeanVarianceCalculator</span><span class="p">(</span>
    <span class="n">obs</span><span class="o">=</span><span class="n">position_observable</span><span class="p">,</span> <span class="n">delta_N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">auto_update_accumulators</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">accumulator</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">accumulator</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">accumulator</span><span class="o">.</span><span class="n">variance</span><span class="p">())</span>
</pre></div>
</div>
<p>In the example above the automatic update of the accumulator is used. However,
it’s also possible to manually update the accumulator by calling
<a class="reference internal" href="espressomd.html#espressomd.accumulators.MeanVarianceCalculator.update" title="espressomd.accumulators.MeanVarianceCalculator.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">espressomd.accumulators.MeanVarianceCalculator.update()</span></code></a>.</p>
</div>
</div>
<div class="section" id="correlations">
<span id="id29"></span><h3><span class="section-number">15.2.4. </span>Correlations<a class="headerlink" href="#correlations" title="Permalink to this headline">¶</a></h3>
<p>Time correlation functions are ubiquitous in statistical mechanics and
molecular simulations when dynamical properties of many-body systems are
concerned. A prominent example is the velocity autocorrelation function,
<span class="math notranslate nohighlight">\(\left&lt; \mathbf{v}(t) \cdot \mathbf{v}(t+\tau) \right&gt;\)</span> which is
used in the Green-Kubo relations. In general, time correlation functions
are of the form</p>
<div class="math notranslate nohighlight">
\[C(\tau) = \left&lt;A\left(t\right) \otimes B\left(t+\tau\right)\right&gt;\]</div>
<p>where <span class="math notranslate nohighlight">\(t\)</span> is time, <span class="math notranslate nohighlight">\(\tau\)</span> is the lag time (time difference)
between the measurements of (vector) observables <span class="math notranslate nohighlight">\(A\)</span> and
<span class="math notranslate nohighlight">\(B\)</span>, and <span class="math notranslate nohighlight">\(\otimes\)</span> is an operator which produces the vector
quantity <span class="math notranslate nohighlight">\(C\)</span> from <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. The ensemble average
<span class="math notranslate nohighlight">\(\left&lt; \cdot \right&gt;\)</span> is taken over all time origins <span class="math notranslate nohighlight">\(t\)</span>.
Correlation functions describing dynamics of large and complex molecules
such as polymers span many orders of magnitude, ranging from MD time
step up to the total simulation time.</p>
<p>A correlator takes one or two observables, obtains values from them during the simulation and
finally uses a fast correlation algorithm which enables efficient computation
of correlation functions spanning many orders of magnitude in the lag time.</p>
<p>The implementation for computing averages and error estimates of a time series
of observables relies on estimates of autocorrelation functions and the
respective autocorrelation times. The correlator provides the same
functionality as a by-product of computing the correlation function.</p>
<p>An example of the usage of observables and correlations is provided in
the script <code class="file docutils literal notranslate"><span class="pre">samples/observables_correlators.py</span></code>.</p>
<div class="section" id="creating-a-correlation">
<span id="id30"></span><h4><span class="section-number">15.2.4.1. </span>Creating a correlation<a class="headerlink" href="#creating-a-correlation" title="Permalink to this headline">¶</a></h4>
<p>Each correlator is represented by an instance of the <a class="reference internal" href="espressomd.html#espressomd.accumulators.Correlator" title="espressomd.accumulators.Correlator"><code class="xref py py-class docutils literal notranslate"><span class="pre">espressomd.accumulators.Correlator</span></code></a>.
Please see its documentation for an explanation of the arguments that have to be passed to the constructor.</p>
<p>Correlators can be registered for automatic updating during the
integration by adding them to <a class="reference internal" href="espressomd.html#espressomd.system.System.auto_update_accumulators" title="espressomd.system.System.auto_update_accumulators"><code class="xref py py-attr docutils literal notranslate"><span class="pre">espressomd.system.System.auto_update_accumulators</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">auto_update_accumulators</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, an update can triggered by calling the <code class="docutils literal notranslate"><span class="pre">update()</span></code> method of the correlator instance.
In that case, one has to make sure to call the update in the correct time intervals.</p>
<p>The current on-the-fly correlation result can of a correlator can be obtained using its <code class="docutils literal notranslate"><span class="pre">result()</span></code> method.
The final result (including the latest data in the buffers) is obtained using the <code class="docutils literal notranslate"><span class="pre">finalize()</span></code> method.
After this, no further update of the correlator is possible.</p>
</div>
<div class="section" id="example-calculating-a-particle-s-diffusion-coefficient">
<span id="id31"></span><h4><span class="section-number">15.2.4.2. </span>Example: Calculating a particle’s diffusion coefficient<a class="headerlink" href="#example-calculating-a-particle-s-diffusion-coefficient" title="Permalink to this headline">¶</a></h4>
<p>For setting up an observable and correlator to obtain the mean square displacement of particle 0, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pos_obs</span> <span class="o">=</span> <span class="n">ParticlePositions</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>
<span class="n">c_pos</span> <span class="o">=</span> <span class="n">Correlator</span><span class="p">(</span><span class="n">obs1</span><span class="o">=</span><span class="n">pos_obs</span><span class="p">,</span> <span class="n">tau_lin</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">tau_max</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">delta_N</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                   <span class="n">corr_operation</span><span class="o">=</span><span class="s2">&quot;square_distance_componentwise&quot;</span><span class="p">,</span> <span class="n">compress1</span><span class="o">=</span><span class="s2">&quot;discard1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain the velocity auto-correlation function of particle 0, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">obs</span> <span class="o">=</span> <span class="n">ParticleVelocities</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>
<span class="n">c_vel</span> <span class="o">=</span> <span class="n">Correlator</span><span class="p">(</span><span class="n">obs1</span><span class="o">=</span><span class="n">vel_obs</span><span class="p">,</span> <span class="n">tau_lin</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">tau_max</span><span class="o">=</span><span class="mf">20.</span><span class="p">,</span> <span class="n">delta_N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                   <span class="n">corr_operation</span><span class="o">=</span><span class="s2">&quot;scalar_product&quot;</span><span class="p">,</span> <span class="n">compress1</span><span class="o">=</span><span class="s2">&quot;discard1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The full example can be found in <code class="file docutils literal notranslate"><span class="pre">samples/diffusion_coefficient.py</span></code>.
Note that in this example, the operation <code class="docutils literal notranslate"><span class="pre">square_distance_componentwise</span></code>
is used, which is not a correlation function in the mathematical sense. Other
available operations include actual correlation functions, as described
in the source documentation of <a class="reference internal" href="espressomd.html#espressomd.accumulators.Correlator" title="espressomd.accumulators.Correlator"><code class="xref py py-class docutils literal notranslate"><span class="pre">espressomd.accumulators.Correlator</span></code></a>.</p>
</div>
</div>
<div class="section" id="details-of-the-multiple-tau-correlation-algorithm">
<span id="id32"></span><h3><span class="section-number">15.2.5. </span>Details of the multiple tau correlation algorithm<a class="headerlink" href="#details-of-the-multiple-tau-correlation-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Here we briefly describe the multiple tau correlator which is
implemented in <em>ESPResSo</em>. For a more detailed description and discussion of its
behavior with respect to statistical and systematic errors, please read
the cited literature. This type of correlator has been in use for years
in the analysis of dynamic light
scattering <span id="id33">[<a class="reference internal" href="bibliography.html#id78" title="K. Schätzel, M. Drewel, and S Stimac. Photon correlation measurements at large lag times: improving statistical accuracy. Journal of Modern Optics, 35(4):711–718, 1988. doi:10.1080/09500348814550731.">Schätzel <em>et al.</em>, 1988</a>]</span>. About a decade later it
found its way to the Fluorescence Correlation Spectroscopy
(FCS) <span id="id34">[<a class="reference internal" href="bibliography.html#id62" title="D Magatti and F Ferri. Fast multi-tau real-time software correlator for dynamic light scattering. Applied Optics, 40(24):4011–4021, 2001. doi:10.1364/AO.40.004011.">Magatti and Ferri, 2001</a>]</span>. The book of Frenkel and
Smit <span id="id35">[<a class="reference internal" href="bibliography.html#id40" title="Daan Frenkel and Berend Smit. Understanding molecular simulation: From algorithms to applications. Academic Press, San Diego, 2nd edition, 2002. ISBN 978-0-12-267351-1. doi:10.1016/B978-0-12-267351-1.X5000-7.">Frenkel and Smit, 2002</a>]</span> describes its application for the
special case of the velocity autocorrelation function.</p>
<div class="figure align-default" id="id38">
<span id="fig-correlator-scheme"></span><a class="reference internal image-reference" href="_images/correlator_scheme.png"><img alt="Schematic representation of buffers in the correlator." src="_images/correlator_scheme.png" style="width: 747.0px; height: 390.0px;" /></a>
<p class="caption"><span class="caption-text">Schematic representation of buffers in the correlator.</span><a class="headerlink" href="#id38" title="Permalink to this image">¶</a></p>
</div>
<p>Let us consider a set of <span class="math notranslate nohighlight">\(N\)</span> observable values as schematically
shown in the figure above, where a value of index <span class="math notranslate nohighlight">\(i\)</span> was
measured at times <span class="math notranslate nohighlight">\(i\delta t\)</span>. We are interested in computing the
correlation function for a range
of lag times <span class="math notranslate nohighlight">\(\tau = (i-j)\delta t\)</span> between the measurements
<span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>. To simplify the notation, we drop
<span class="math notranslate nohighlight">\(\delta t\)</span> when referring to observables and lag times.</p>
<p>The trivial implementation takes all possible pairs of values
corresponding to lag times
<span class="math notranslate nohighlight">\(\tau \in [{\tau_{\mathrm{min}}}:{\tau_{\mathrm{max}}}]\)</span>. Without
loss of generality, we consider
<span class="math notranslate nohighlight">\({\tau_{\mathrm{min}}}=0\)</span>. The computational effort for such an
algorithm scales as
<span class="math notranslate nohighlight">\({\cal O} \bigl({\tau_{\mathrm{max}}}^2\bigr)\)</span>. As a rule of
thumb, this is feasible if <span class="math notranslate nohighlight">\({\tau_{\mathrm{max}}}&lt; 10^3\)</span>. The
multiple tau correlator provides a solution to compute the correlation
functions for arbitrary range of the lag times by coarse-graining the
high <span class="math notranslate nohighlight">\(\tau\)</span> values. It applies the naive algorithm to a relatively
small range of lag times <span class="math notranslate nohighlight">\(\tau \in [0:p-1]\)</span>
(<span class="math notranslate nohighlight">\(p\)</span> corresponds to parameter <code class="docutils literal notranslate"><span class="pre">tau_lin</span></code>).
This we refer to as compression level 0.
To compute the correlations for lag times
<span class="math notranslate nohighlight">\(\tau \in [p:2(p-1)]\)</span>, the original data are first coarse-grained,
so that <span class="math notranslate nohighlight">\(m\)</span> values of the original data are compressed to produce
a single data point in the higher compression level. Thus the lag time
between the neighboring values in the higher compression level
increases by a factor of <span class="math notranslate nohighlight">\(m\)</span>, while the number of stored values
decreases by the same factor and the number of correlation operations at
this level reduces by a factor of <span class="math notranslate nohighlight">\(m^2\)</span>. Correlations for lag
times <span class="math notranslate nohighlight">\(\tau \in [2p:4(p-1)]\)</span> are computed at compression level 2,
which is created in an analogous manner from level 1. This can continue
hierarchically up to an arbitrary level for which enough data is
available. Due to the hierarchical reduction of the data, the algorithm
scales as
<span class="math notranslate nohighlight">\({\cal O} \bigl( p^2 \log({\tau_{\mathrm{max}}}) \bigr)\)</span>. Thus an
additional order of magnitude in <span class="math notranslate nohighlight">\({\tau_{\mathrm{max}}}\)</span> costs
just a constant extra effort.</p>
<p>The speedup is gained at the expense of statistical accuracy. The loss
of accuracy occurs at the compression step. In principle one can use any
value of <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(p\)</span> to tune the algorithm performance.
However, it turns out that using a high <span class="math notranslate nohighlight">\(m\)</span> dilutes the data at
high <span class="math notranslate nohighlight">\(\tau\)</span>. Therefore <span class="math notranslate nohighlight">\(m=2\)</span> is hard-coded in the correlator
and cannot be modified by user. The value of <span class="math notranslate nohighlight">\(p\)</span> remains an
adjustable parameter which can be modified by user by setting when
defining a correlation. In general, one should choose <span class="math notranslate nohighlight">\(p \gg m\)</span> to
avoid loss of statistical accuracy. Choosing <span class="math notranslate nohighlight">\(p=16\)</span> seems to be
safe but it may depend on the properties of the analyzed correlation
functions. A detailed analysis has been performed in
Ref. <span id="id36">[<a class="reference internal" href="bibliography.html#id73" title="Jorge Ramirez, Sathish K. Sukumaran, Bart Vorselaars, and Alexei E. Likhtman. Efficient on the fly calculation of time correlation functions in computer simulations. The Journal of Chemical Physics, 133(15):154103, 2010. doi:10.1063/1.3491098.">Ramirez <em>et al.</em>, 2010</a>]</span>.</p>
<p>The choice of the compression function also influences the statistical
accuracy and can even lead to systematic errors. The default compression
function discards the second value and
pushes the first one to the higher level. This is robust and can be
applied universally to any combination of observables and correlation
operation. On the other hand, it reduces the statistical accuracy as the
compression level increases. In many cases, the compression operation
can be applied, which averages the two neighboring values and the
average then enters the higher level, preserving almost the full
statistical accuracy of the original data. In general, if averaging can
be safely used or not, depends on the properties of the difference</p>
<div class="math notranslate nohighlight">
\[\frac{1}{2} (A_i \otimes B_{i+p} + A_{i+1} \otimes B_{i+p+1} ) -
\frac{1}{2} (A_i + A_{i+1} ) \otimes \frac{1}{2} (B_{i+p} +  B_{i+p+1})
\label{eq:difference}\]</div>
<p>For example in the case of velocity autocorrelation function, the
above-mentioned difference has a small value and a random sign,
different contributions cancel each other. On the other hand, in the of
the case of mean square displacement the difference is always positive,
resulting in a non-negligible systematic error. A more general
discussion is presented in Ref. <span id="id37">[<a class="reference internal" href="bibliography.html#id73" title="Jorge Ramirez, Sathish K. Sukumaran, Bart Vorselaars, and Alexei E. Likhtman. Efficient on the fly calculation of time correlation functions in computer simulations. The Journal of Chemical Physics, 133(15):154103, 2010. doi:10.1063/1.3491098.">Ramirez <em>et al.</em>, 2010</a>]</span>.</p>
</div>
</div>
<div class="section" id="cluster-analysis">
<h2><span class="section-number">15.3. </span>Cluster analysis<a class="headerlink" href="#cluster-analysis" title="Permalink to this headline">¶</a></h2>
<p><em>ESPResSo</em> provides support for online cluster analysis. Here, a cluster
is a group of particles, such that you can get from any particle
to any second particle by at least one path of neighboring particles.
I.e., if particle B is a neighbor of particle A, particle C is a neighbor
of A and particle D is a neighbor of particle B, all four particles are
part of the same cluster. The cluster analysis is available in parallel
simulations, but the analysis is carried out on the head node, only.</p>
<p>Whether or not two particles are neighbors is defined by a pair criterion.
The available criteria can be found in <a class="reference internal" href="espressomd.html#module-espressomd.pair_criteria" title="espressomd.pair_criteria"><code class="xref py py-mod docutils literal notranslate"><span class="pre">espressomd.pair_criteria</span></code></a>.
For example, a distance criterion which will consider particles as neighbors
if they are closer than 0.11 is created as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd.pair_criteria</span>
<span class="n">dc</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">pair_criteria</span><span class="o">.</span><span class="n">DistanceCriterion</span><span class="p">(</span><span class="n">cut_off</span><span class="o">=</span><span class="mf">0.11</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain the cluster structure of a system, an instance of
<a class="reference internal" href="espressomd.html#espressomd.cluster_analysis.ClusterStructure" title="espressomd.cluster_analysis.ClusterStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">espressomd.cluster_analysis.ClusterStructure</span></code></a> has to be created.
To to create a cluster structure with above criterion:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd.cluster_analysis</span>
<span class="n">cs</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">cluster_analysis</span><span class="o">.</span><span class="n">ClusterStructure</span><span class="p">(</span><span class="n">distance_criterion</span><span class="o">=</span><span class="n">dc</span><span class="p">)</span>
</pre></div>
</div>
<p>In most cases, the cluster analysis is carried out by calling the
<a class="reference internal" href="espressomd.html#espressomd.cluster_analysis.ClusterStructure.run_for_all_pairs" title="espressomd.cluster_analysis.ClusterStructure.run_for_all_pairs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">espressomd.cluster_analysis.ClusterStructure.run_for_all_pairs</span></code></a> method.
When the pair criterion is purely based on bonds,
<a class="reference internal" href="espressomd.html#espressomd.cluster_analysis.ClusterStructure.run_for_bonded_particles" title="espressomd.cluster_analysis.ClusterStructure.run_for_bonded_particles"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">espressomd.cluster_analysis.ClusterStructure.run_for_bonded_particles</span></code></a> can be used.</p>
<p>The results can be accessed via ClusterStructure.clusters, which is an instance of
<a class="reference internal" href="espressomd.html#espressomd.cluster_analysis.Clusters" title="espressomd.cluster_analysis.Clusters"><code class="xref any py py-class docutils literal notranslate"><span class="pre">espressomd.cluster_analysis.Clusters</span></code></a>.</p>
<p>Individual clusters are represented by instances of
<a class="reference internal" href="espressomd.html#espressomd.cluster_analysis.Cluster" title="espressomd.cluster_analysis.Cluster"><code class="xref any py py-class docutils literal notranslate"><span class="pre">espressomd.cluster_analysis.Cluster</span></code></a>, which provides access to the
particles contained in a cluster as well as per-cluster analysis routines
such as radius of gyration, center of mass and longest distance.
Note that the cluster objects do not contain copies of the particles,
but refer to the particles in the simulation. Hence, the objects become
outdated if the simulation system changes. On the other hand, it is possible
to directly manipulate the particles contained in a cluster.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">15. Analysis</a><ul>
<li><a class="reference internal" href="#direct-analysis-routines">15.1. Direct analysis routines</a><ul>
<li><a class="reference internal" href="#energies">15.1.1. Energies</a></li>
<li><a class="reference internal" href="#momentum-of-the-system">15.1.2. Momentum of the System</a></li>
<li><a class="reference internal" href="#minimal-distances-between-particles">15.1.3. Minimal distances between particles</a></li>
<li><a class="reference internal" href="#particles-in-the-neighborhood">15.1.4. Particles in the neighborhood</a></li>
<li><a class="reference internal" href="#particle-distribution">15.1.5. Particle distribution</a></li>
<li><a class="reference internal" href="#structure-factor">15.1.6. Structure factor</a></li>
<li><a class="reference internal" href="#center-of-mass">15.1.7. Center of mass</a></li>
<li><a class="reference internal" href="#moment-of-inertia-matrix">15.1.8. Moment of inertia matrix</a></li>
<li><a class="reference internal" href="#gyration-tensor">15.1.9. Gyration tensor</a></li>
<li><a class="reference internal" href="#pressure">15.1.10. Pressure</a></li>
<li><a class="reference internal" href="#pressure-tensor">15.1.11. Pressure Tensor</a></li>
<li><a class="reference internal" href="#chains">15.1.12. Chains</a></li>
</ul>
</li>
<li><a class="reference internal" href="#observables-framework">15.2. Observables framework</a><ul>
<li><a class="reference internal" href="#using-observables">15.2.1. Using observables</a></li>
<li><a class="reference internal" href="#available-observables">15.2.2. Available observables</a></li>
<li><a class="reference internal" href="#accumulators">15.2.3. Accumulators</a></li>
<li><a class="reference internal" href="#correlations">15.2.4. Correlations</a></li>
<li><a class="reference internal" href="#details-of-the-multiple-tau-correlation-algorithm">15.2.5. Details of the multiple tau correlation algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cluster-analysis">15.3. Cluster analysis</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2021, The ESPResSo project.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>