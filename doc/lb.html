<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>13. Lattice-Boltzmann &#8212; ESPResSo 5.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=97504538" />
    <link rel="stylesheet" type="text/css" href="_static/blockquotes.css?v=270de11a" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=539bf778" />
    <script src="_static/documentation_options.js?v=ce74c6a2"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/toggleprompt.js?v=5801b3bb"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="14. Electrokinetics" href="ek.html" />
    <link rel="prev" title="12. Single particle forces (constraints)" href="constraints.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="lattice-boltzmann">
<span id="id1"></span><h1><span class="section-number">13. </span>Lattice-Boltzmann<a class="headerlink" href="#lattice-boltzmann" title="Link to this heading">¶</a></h1>
<p>For an implicit treatment of a solvent, ESPResSo can couple the molecular
dynamics simulation to a lattice-Boltzmann fluid. The lattice-Boltzmann
method (LBM) is a fast, lattice-based method that, in its “pure” form,
allows to calculate fluid flow in different boundary conditions of
arbitrarily complex geometries. Coupled to molecular dynamics,
it allows for the computationally efficient inclusion of hydrodynamic
interactions into the simulation. The focus of the ESPResSo implementation
of the LBM is, of course, the coupling to MD and therefore available
geometries and boundary conditions are somewhat limited in comparison to
“pure” LB codes.</p>
<p>Here we restrict the documentation to the interface. For a more detailed
description of the method, please refer to the literature.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please cite <span id="id2">Godenschwager <em>et al.</em> [<a class="reference internal" href="bibliography.html#id54" title="Christian Godenschwager, Florian Schornbaum, Martin Bauer, Harald Köstler, and Ulrich Rüde. A framework for hybrid parallel flow simulations with a trillion cells in complex geometries. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis. New York, 2013. Association for Computing Machinery. doi:10.1145/2503210.2503273.">2013</a>]</span> and <span id="id3">Bauer <em>et al.</em> [<a class="reference internal" href="bibliography.html#id19" title="Martin Bauer, Sebastian Eibl, Christian Godenschwager, Nils Kohl, Michael Kuron, Christoph Rettinger, Florian Schornbaum, Christoph Schwarzmeier, Dominik Thönnes, Harald Köstler, and Ulrich Rüde. waLBerla: a block-structured high-performance framework for multiphysics simulations. Computers &amp; Mathematics with Applications, 81:478–501, 2021. doi:10.1016/j.camwa.2020.01.007.">2021</a>]</span> (BibTeX keys
<code class="docutils literal notranslate"><span class="pre">godenschwager13a</span></code> and <code class="docutils literal notranslate"><span class="pre">bauer21a</span></code> in <code class="file docutils literal notranslate"><span class="pre">doc/bibliography.bib</span></code>) if
you use the LB fluid. When generating your own kernels with pystencils and
lbmpy, please also cite <span id="id4">Bauer <em>et al.</em> [<a class="reference internal" href="bibliography.html#id18" title="Martin Bauer, Johannes Hötzer, Dominik Ernst, Julian Hammer, Marco Seiz, Henrik Hierl, Jan Hönig, Harald Köstler, Gerhard Wellein, Britta Nestler, and Ulrich Rüde. Code generation for massively parallel phase-field simulations. In Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis. New York, New York, USA, November 2019. Association for Computing Machinery. doi:10.1145/3295500.3356186.">2019</a>]</span> and <span id="id5">Bauer <em>et al.</em> [<a class="reference internal" href="bibliography.html#id20" title="Martin Bauer, Harald Köstler, and Ulrich Rüde. lbmpy: automatic code generation for efficient parallel lattice Boltzmann methods. Journal of Computational Science, 49:101269, 2021. doi:10.1016/j.jocs.2020.101269.">2021</a>]</span> (BibTeX
key <code class="docutils literal notranslate"><span class="pre">bauer19a</span></code> resp. <code class="docutils literal notranslate"><span class="pre">bauer21b</span></code> in <code class="file docutils literal notranslate"><span class="pre">doc/bibliography.bib</span></code>).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires external feature <code class="docutils literal notranslate"><span class="pre">WALBERLA</span></code>, enabled with the CMake option
<code class="docutils literal notranslate"><span class="pre">-D</span> <span class="pre">ESPRESSO_BUILD_WITH_WALBERLA=ON</span></code>.</p>
</div>
<section id="setting-up-a-lb-fluid">
<span id="id6"></span><h2><span class="section-number">13.1. </span>Setting up a LB fluid<a class="headerlink" href="#setting-up-a-lb-fluid" title="Link to this heading">¶</a></h2>
<p>The following minimal example illustrates how to use the LBM in ESPResSo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd</span>
<span class="kn">import</span> <span class="nn">espressomd.lb</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
<span class="n">system</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">system</span><span class="o">.</span><span class="n">cell_system</span><span class="o">.</span><span class="n">skin</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="n">lbf</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">LBFluidWalberla</span><span class="p">(</span><span class="n">agrid</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kinematic_viscosity</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">lb</span> <span class="o">=</span> <span class="n">lbf</span>
<span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>To use the GPU-accelerated variant, replace line 6 in the example above by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lbf</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">LBFluidWalberlaGPU</span><span class="p">(</span><span class="n">agrid</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kinematic_viscosity</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Feature <code class="docutils literal notranslate"><span class="pre">CUDA</span></code> required for the GPU-accelerated variant</p>
</div>
<p>To use the (much faster) GPU implementation of the LBM, use
<a class="reference internal" href="espressomd.html#espressomd.lb.LBFluidWalberlaGPU" title="espressomd.lb.LBFluidWalberlaGPU"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBFluidWalberlaGPU</span></code></a> in place of <a class="reference internal" href="espressomd.html#espressomd.lb.LBFluidWalberla" title="espressomd.lb.LBFluidWalberla"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBFluidWalberla</span></code></a>.
Please note that the GPU implementation uses single precision floating point operations.
This decreases the accuracy of calculations compared to the CPU implementation.
In particular, due to rounding errors, the fluid density decreases over time,
when external forces, coupling to particles, or thermalization is used.
The loss of density is on the order of <span class="math notranslate nohighlight">\(10^{-12}\)</span> per time step.</p>
<p>The command initializes the fluid with a given set of parameters. It is
also possible to change parameters on the fly, but this will only rarely
be done in practice. Before being able to use the LBM, it is necessary
to set up a box of a desired size. The parameter is used to set the
lattice constant of the fluid, so the size of the box in every direction
must be a multiple of <code class="docutils literal notranslate"><span class="pre">agrid</span></code>.</p>
<p>In the following, we discuss the parameters that can be supplied to the LBM in ESPResSo.
The detailed interface definition is available at <a class="reference internal" href="espressomd.html#espressomd.lb.LBFluidWalberla" title="espressomd.lb.LBFluidWalberla"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBFluidWalberla</span></code></a>.</p>
<p>The LB scheme and the MD scheme are not synchronized: In one LB time
step typically several MD steps are performed. This allows to speed up
the simulations and is adjusted with the parameter <code class="docutils literal notranslate"><span class="pre">tau</span></code>, the LB time step.
The parameters <code class="docutils literal notranslate"><span class="pre">density</span></code> and <code class="docutils literal notranslate"><span class="pre">kinematic_viscosity</span></code> set up the density and kinematic viscosity of the
LB fluid in (usual) MD units. Internally the LB implementation works
with a different set of units: all lengths are expressed in <code class="docutils literal notranslate"><span class="pre">agrid</span></code>, all times
in <code class="docutils literal notranslate"><span class="pre">tau</span></code> and so on.
LB nodes are located at 0.5, 1.5, 2.5, etc.
(in terms of <code class="docutils literal notranslate"><span class="pre">agrid</span></code>). This has important implications for the location of
hydrodynamic boundaries which are generally considered to be halfway
between two nodes for flat, axis-aligned walls. For more complex boundary geometries,
the hydrodynamic boundary location deviates from this midpoint and the deviation
decays to first order in <code class="docutils literal notranslate"><span class="pre">agrid</span></code>. The LBM should
<em>not be used as a black box</em>, but only after a careful check of all
parameters that were applied.</p>
<p>In the following, we describe a number of optional parameters.
Thermalization of the fluid (and particle coupling later on) can be activated by
providing a non-zero value for the parameter <code class="docutils literal notranslate"><span class="pre">kT</span></code>. Then, a seed has to be provided for
the fluid thermalization:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lb</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">LBFluidWalberla</span><span class="p">(</span><span class="n">kT</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">134</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">ext_force_density</span></code> takes a three dimensional vector as an
array_like of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, representing a homogeneous external body force density in MD
units to be applied to the fluid.</p>
<p>Before running a simulation at least the following parameters must be
set up: <code class="docutils literal notranslate"><span class="pre">agrid</span></code>, <code class="docutils literal notranslate"><span class="pre">tau</span></code>, <code class="docutils literal notranslate"><span class="pre">kinematic_viscosity</span></code>, <code class="docutils literal notranslate"><span class="pre">density</span></code>.</p>
<p>To detach the LBM solver, use this syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">lb</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<section id="performance-considerations">
<h3><span class="section-number">13.1.1. </span>Performance considerations<a class="headerlink" href="#performance-considerations" title="Link to this heading">¶</a></h3>
<p>The CPU implementation of the LB has an extra flag <code class="docutils literal notranslate"><span class="pre">single_precision</span></code> to
use single-precision floating point values. These are approximately 10%
faster than double-precision, at the cost of a small loss in precision.</p>
<p>To enable vectorization, run <code class="docutils literal notranslate"><span class="pre">cmake</span> <span class="pre">.</span> <span class="pre">-D</span> <span class="pre">ESPRESSO_BUILD_WITH_WALBERLA_AVX=ON</span></code>.
The SIMD kernels have better performance over the regular kernels, because
they carry out the mathematical operations in batches of 4 values at a time
(in double-precision mode) or 8 values at a time (in single-precision mode)
along the x-axis. An AVX2-capable microprocessor is required; to check if
your hardware supports it, run the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>lscpu<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>avx2
</pre></div>
</div>
<p>For small simulation boxes, best performance is obtained by making the box
length along the x-axis an integer multiple of the vector size, times agrid.</p>
</section>
</section>
<section id="checkpointing">
<span id="checkpointing-lb"></span><h2><span class="section-number">13.2. </span>Checkpointing<a class="headerlink" href="#checkpointing" title="Link to this heading">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lb</span><span class="o">.</span><span class="n">save_checkpoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">binary</span><span class="p">)</span>
<span class="n">lb</span><span class="o">.</span><span class="n">load_checkpoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">binary</span><span class="p">)</span>
</pre></div>
</div>
<p>The first command saves all of the LB fluid nodes’ populations to an ASCII
(<code class="docutils literal notranslate"><span class="pre">binary=False</span></code>) or binary (<code class="docutils literal notranslate"><span class="pre">binary=True</span></code>) format respectively.
The second command loads the LB fluid nodes’ populations.
In both cases <code class="docutils literal notranslate"><span class="pre">path</span></code> specifies the location of the
checkpoint file. This is useful for restarting a simulation either on the same
machine or a different machine. Some care should be taken when using the binary
format as the format of doubles can depend on both the computer being used as
well as the compiler. One thing that one needs to be aware of is that loading
the checkpoint also requires the user to reuse the old forces. This is
necessary since the coupling force between the particles and the fluid has
already been applied to the fluid. Failing to reuse the old forces breaks
momentum conservation, which is in general a problem. It is particularly
problematic for bulk simulations as the system as a whole acquires a drift of
the center of mass, causing errors in the calculation of velocities and
diffusion coefficients. The correct way to restart an LB simulation is to first
load in the particles with the correct forces, and use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="n">number_of_steps</span><span class="p">,</span> <span class="n">reuse_forces</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>upon the first call <code class="docutils literal notranslate"><span class="pre">integrator.run</span></code>. This causes the
old forces to be reused and thus conserves momentum.</p>
</section>
<section id="interpolating-velocities">
<span id="id7"></span><h2><span class="section-number">13.3. </span>Interpolating velocities<a class="headerlink" href="#interpolating-velocities" title="Link to this heading">¶</a></h2>
<p>To get interpolated velocity values between lattice nodes, the function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lb</span><span class="o">.</span><span class="n">get_interpolated_velocity</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">])</span>
</pre></div>
</div>
<p>with a single position  <code class="docutils literal notranslate"><span class="pre">pos</span></code> as an argument can be used.</p>
<p>The interpolation is done linearly between the nearest 8 LB nodes.</p>
<p>A note on boundaries:
both interpolation schemes don’t take into account the physical location of the boundaries
(e.g. in the middle between two nodes for a planar wall) but will use the boundary node slip velocity
at the node position. This means that every interpolation involving at least one
boundary node will introduce an error.</p>
</section>
<section id="coupling-lb-to-a-md-simulation">
<span id="id8"></span><h2><span class="section-number">13.4. </span>Coupling LB to a MD simulation<a class="headerlink" href="#coupling-lb-to-a-md-simulation" title="Link to this heading">¶</a></h2>
<p>MD particles can be coupled to a LB fluid through frictional coupling. The friction force</p>
<div class="math notranslate nohighlight">
\[F_{i,\text{frict}} = - \gamma (v_i(t)-u(x_i(t),t))\]</div>
<p>depends on the particle velocity <span class="math notranslate nohighlight">\(v\)</span> and the fluid velocity <span class="math notranslate nohighlight">\(u\)</span>. It acts both
on the particle and the fluid (in opposite direction). Because the fluid is also affected,
multiple particles can interact via hydrodynamic interactions. As friction in molecular systems is
accompanied by fluctuations, the particle-fluid coupling has to be activated through
the <a class="reference internal" href="integration.html#lb-thermostat"><span class="std std-ref">Lattice-Boltzmann thermostat</span></a> (see more detailed description there). A short example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">thermostat</span><span class="o">.</span><span class="n">set_lb</span><span class="p">(</span><span class="n">LB_fluid</span><span class="o">=</span><span class="n">lbf</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">lbf</span></code> is an instance of either <a class="reference internal" href="espressomd.html#espressomd.lb.LBFluidWalberla" title="espressomd.lb.LBFluidWalberla"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBFluidWalberla</span></code></a> or
<a class="reference internal" href="espressomd.html#espressomd.lb.LBFluidWalberlaGPU" title="espressomd.lb.LBFluidWalberlaGPU"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBFluidWalberlaGPU</span></code></a>, <code class="docutils literal notranslate"><span class="pre">gamma</span></code> the friction coefficient and
<code class="docutils literal notranslate"><span class="pre">seed</span></code> the seed for the random number generator involved
in the thermalization.</p>
<section id="lb-and-lebc">
<span id="id9"></span><h3><span class="section-number">13.4.1. </span>LB and LEbc<a class="headerlink" href="#lb-and-lebc" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="system_setup.html#lees-edwards-boundary-conditions"><span class="std std-ref">Lees–Edwards boundary conditions</span></a> (LEbc) are supported by both
LB implementations, which follow the derivation in <span id="id10">[<a class="reference internal" href="bibliography.html#id127" title="Alexander J. Wagner and Ignacio Pagonabarraga. Lees–Edwards boundary conditions for lattice Boltzmann. Journal of Statistical Physics, 107(112):521–537, 2002. doi:10.1023/A:1014595628808.">Wagner and Pagonabarraga, 2002</a>]</span>.
Note, that there is no extra python interface for the use of LEbc
with the LB algorithm: all the necessary information is internally
derived from the currently active MD LEbc protocol in
<code class="docutils literal notranslate"><span class="pre">system.lees_edwards.protocol</span></code>.
Therefore, the MD LEbc must be set before the LB actor is instantiated.
Use the <a class="reference internal" href="espressomd.html#espressomd.lees_edwards.Off" title="espressomd.lees_edwards.Off"><code class="xref py py-class docutils literal notranslate"><span class="pre">Off</span></code></a> if the system should have
no shearing initially; this action will initialize the shear axes, and
when the LB actor is instantiated, the Lees-Edwards collision kernels
will be used instead of the default ones.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>At the moment, LB only supports the case <code class="docutils literal notranslate"><span class="pre">shear_plane_normal=&quot;y&quot;</span></code> and
doesn’t allow domain decomposition along the shear and normal directions.</p>
</div>
</section>
</section>
<section id="reading-and-setting-properties-of-single-lattice-nodes">
<span id="id11"></span><h2><span class="section-number">13.5. </span>Reading and setting properties of single lattice nodes<a class="headerlink" href="#reading-and-setting-properties-of-single-lattice-nodes" title="Link to this heading">¶</a></h2>
<p>Appending three indices to the <code class="docutils literal notranslate"><span class="pre">lb</span></code> object returns an object that represents
the selected LB grid node and allows one to access all of its properties:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lb</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">density</span>              <span class="c1"># fluid density (scalar)</span>
<span class="n">lb</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">velocity</span>             <span class="c1"># fluid velocity (3-vector)</span>
<span class="n">lb</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">pressure_tensor</span>      <span class="c1"># fluid pressure tensor (symmetric 3x3 matrix)</span>
<span class="n">lb</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">pressure_tensor_neq</span>  <span class="c1"># fluid pressure tensor non-equilibrium part (symmetric 3x3 matrix)</span>
<span class="n">lb</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">is_boundary</span>          <span class="c1"># flag indicating whether the node is fluid or boundary (boolean)</span>
</pre></div>
</div>
<p>All of these properties are read-only.
The indices <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span></code> are integers and enumerate the LB nodes in the three Cartesian directions,
starting at 0. To modify <code class="docutils literal notranslate"><span class="pre">is_boundary</span></code>, refer to <a class="reference internal" href="#setting-up-lb-boundary-conditions"><span class="std std-ref">Setting up boundary conditions</span></a>.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">velocity</span><span class="p">)</span>
<span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="mf">1.2</span>
</pre></div>
</div>
<p>The first line prints the fluid velocity at node (0 0 0) to the screen.
The second line sets this fluid node’s density to the value <code class="docutils literal notranslate"><span class="pre">1.2</span></code>.
Use negative indices to get nodes starting from the end of the lattice.</p>
<p>The nodes can be read and modified using slices. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">velocity</span><span class="p">)</span>
<span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.2</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">1.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.4</span><span class="p">]]]</span>
</pre></div>
</div>
<p>The first line prints an array of shape (2, 2, 1, 3) with the velocities
of nodes (0 0 0), (0 1 0), (2 0 0), (2 1 0). The second line updates
these nodes with densities ranging from 1.1 to 1.4. You can set either
a value that matches the length of the slice (which sets each node
individually), or a single value that will be copied to every node
(e.g. a scalar for density, or an array of length 3 for the velocity).</p>
<p>The LB pressure tensor from property <code class="docutils literal notranslate"><span class="pre">pressure_tensor</span></code> is calculated as
<span class="math notranslate nohighlight">\(\Pi = \rho c_s^2 \mathbb{1} + \rho \mathbf{u} \otimes \mathbf{u}\)</span>
with <span class="math notranslate nohighlight">\(\rho\)</span> the fluid density at a particular node, <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>
the fluid velocity at a particular node, <span class="math notranslate nohighlight">\(c_s\)</span> the speed of sound and
<span class="math notranslate nohighlight">\(\mathbb{1}\)</span> the identity matrix. The non-equilibrium part from property
<code class="docutils literal notranslate"><span class="pre">pressure_tensor_neq</span></code> is defined as <span class="math notranslate nohighlight">\(\Pi^{\text{neq}} = \rho \mathbf{u} \otimes \mathbf{u}\)</span>.</p>
</section>
<section id="vtk-output">
<span id="lb-vtk-output"></span><h2><span class="section-number">13.6. </span>VTK output<a class="headerlink" href="#vtk-output" title="Link to this heading">¶</a></h2>
<p>The waLBerla library implements a globally-accessible VTK registry.
A VTK stream can be attached to a LB actor to periodically write
one or multiple fluid field data into a single file using
<a class="reference internal" href="espressomd.html#espressomd.lb.VTKOutput" title="espressomd.lb.VTKOutput"><code class="xref py py-class docutils literal notranslate"><span class="pre">VTKOutput</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vtk_obs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="s2">&quot;velocity_vector&quot;</span><span class="p">]</span>
<span class="c1"># create a VTK callback that automatically writes every 10 LB steps</span>
<span class="n">lb_vtk</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">VTKOutput</span><span class="p">(</span>
    <span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;lb_vtk_automatic&quot;</span><span class="p">,</span> <span class="n">observables</span><span class="o">=</span><span class="n">vtk_obs</span><span class="p">,</span> <span class="n">delta_N</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">lb</span><span class="o">.</span><span class="n">add_vtk_writer</span><span class="p">(</span><span class="n">vtk</span><span class="o">=</span><span class="n">lb_vtk</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="c1"># can be deactivated</span>
<span class="n">lb_vtk</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">lb_vtk</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
<span class="c1"># create a VTK callback that writes only when explicitly called</span>
<span class="n">lb_vtk_on_demand</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">VTKOutput</span><span class="p">(</span>
    <span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;lb_vtk_now&quot;</span><span class="p">,</span> <span class="n">observables</span><span class="o">=</span><span class="n">vtk_obs</span><span class="p">)</span>
<span class="n">lb</span><span class="o">.</span><span class="n">add_vtk_writer</span><span class="p">(</span><span class="n">vtk</span><span class="o">=</span><span class="n">lb_vtk_on_demand</span><span class="p">)</span>
<span class="n">lb_vtk_on_demand</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
</pre></div>
</div>
<p>Currently supported fluid properties are the density, velocity vector
and pressure tensor. By default, the properties of the current state
of the fluid are written to disk on demand. To add a stream that writes
to disk continuously, use the optional argument <code class="docutils literal notranslate"><span class="pre">delta_N</span></code> to indicate
the level of subsampling. Such a stream can be deactivated.</p>
<p>The VTK format is readable by visualization software such as ParaView <a class="footnote-reference brackets" href="#id19" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
or Mayavi2 <a class="footnote-reference brackets" href="#id20" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, as well as in ESPResSo (see <a class="reference internal" href="io.html#reading-vtk-files"><span class="std std-ref">Reading VTK files</span></a>).
If you plan to use ParaView for visualization, note that also the particle
positions can be exported using the VTK format
(see <a class="reference internal" href="espressomd.html#espressomd.particle_data.ParticleList.writevtk" title="espressomd.particle_data.ParticleList.writevtk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writevtk()</span></code></a>).</p>
<p>Important: these VTK files are written in multi-piece format, i.e. each MPI
rank writes its local domain to a new piece in the VTK uniform grid to avoid
a MPI reduction. ParaView can handle the topology reconstruction natively.
However, when reading the multi-piece file with the Python <code class="docutils literal notranslate"><span class="pre">vtk</span></code> package,
the topology must be manually reconstructed. In particular, calling the XML
reader <code class="docutils literal notranslate"><span class="pre">GetOutput()</span></code> method directly after the update step will erase all
topology information. While this is not an issue for VTK files obtained from
simulations that ran with 1 MPI rank, for parallel simulations this will lead
to 3D grids with incorrectly ordered data. Automatic topology reconstruction
is available through <a class="reference internal" href="espressomd.io.html#espressomd.io.vtk.VTKReader" title="espressomd.io.vtk.VTKReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">VTKReader</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">espressomd</span>
<span class="kn">import</span> <span class="nn">espressomd.lb</span>
<span class="kn">import</span> <span class="nn">espressomd.io.vtk</span>

<span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mf">12.</span><span class="p">,</span> <span class="mf">14.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">])</span>
<span class="n">system</span><span class="o">.</span><span class="n">cell_system</span><span class="o">.</span><span class="n">skin</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="n">system</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="n">lbf</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">LBFluidWalberla</span><span class="p">(</span>
    <span class="n">agrid</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">kinematic_viscosity</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">lb</span> <span class="o">=</span> <span class="n">lbf</span>
<span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">vtk_reader</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">vtk</span><span class="o">.</span><span class="n">VTKReader</span><span class="p">()</span>
<span class="n">label_density</span> <span class="o">=</span> <span class="s2">&quot;density&quot;</span>
<span class="n">label_velocity</span> <span class="o">=</span> <span class="s2">&quot;velocity_vector&quot;</span>
<span class="n">label_pressure</span> <span class="o">=</span> <span class="s2">&quot;pressure_tensor&quot;</span>

<span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmp_directory</span><span class="p">:</span>
    <span class="n">path_vtk_root</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">tmp_directory</span><span class="p">)</span>
    <span class="n">label_vtk</span> <span class="o">=</span> <span class="s2">&quot;lb_vtk&quot;</span>
    <span class="n">path_vtk</span> <span class="o">=</span> <span class="n">path_vtk_root</span> <span class="o">/</span> <span class="n">label_vtk</span> <span class="o">/</span> <span class="s2">&quot;simulation_step_0.vtu&quot;</span>

    <span class="c1"># write VTK file</span>
    <span class="n">lb_vtk</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">VTKOutput</span><span class="p">(</span>
        <span class="n">identifier</span><span class="o">=</span><span class="n">label_vtk</span><span class="p">,</span> <span class="n">delta_N</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">observables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="s2">&quot;velocity_vector&quot;</span><span class="p">,</span> <span class="s2">&quot;pressure_tensor&quot;</span><span class="p">],</span>
        <span class="n">base_folder</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">path_vtk_root</span><span class="p">))</span>
    <span class="n">lbf</span><span class="o">.</span><span class="n">add_vtk_writer</span><span class="p">(</span><span class="n">vtk</span><span class="o">=</span><span class="n">lb_vtk</span><span class="p">)</span>
    <span class="n">lb_vtk</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>

    <span class="c1"># read VTK file</span>
    <span class="n">vtk_grids</span> <span class="o">=</span> <span class="n">vtk_reader</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">path_vtk</span><span class="p">)</span>
    <span class="n">vtk_density</span> <span class="o">=</span> <span class="n">vtk_grids</span><span class="p">[</span><span class="n">label_density</span><span class="p">]</span>
    <span class="n">vtk_velocity</span> <span class="o">=</span> <span class="n">vtk_grids</span><span class="p">[</span><span class="n">label_velocity</span><span class="p">]</span>
    <span class="n">vtk_pressure</span> <span class="o">=</span> <span class="n">vtk_grids</span><span class="p">[</span><span class="n">label_pressure</span><span class="p">]</span>
    <span class="n">vtk_pressure</span> <span class="o">=</span> <span class="n">vtk_pressure</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vtk_pressure</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># check VTK values match node values</span>
    <span class="n">lb_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lbf</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">density</span><span class="p">)</span>
    <span class="n">lb_velocity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lbf</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">velocity</span><span class="p">)</span>
    <span class="n">lb_pressure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lbf</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">pressure_tensor</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">vtk_density</span><span class="p">,</span> <span class="n">lb_density</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">vtk_velocity</span><span class="p">,</span> <span class="n">lb_velocity</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">vtk_pressure</span><span class="p">,</span> <span class="n">lb_pressure</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="choosing-between-the-gpu-and-cpu-implementations">
<span id="id14"></span><h2><span class="section-number">13.7. </span>Choosing between the GPU and CPU implementations<a class="headerlink" href="#choosing-between-the-gpu-and-cpu-implementations" title="Link to this heading">¶</a></h2>
<p>ESPResSo contains an implementation of the LBM for NVIDIA
GPUs using the CUDA framework. On CUDA-supporting machines this can be
activated by compiling with the feature <code class="docutils literal notranslate"><span class="pre">CUDA</span></code>. Within the
Python script, the <a class="reference internal" href="espressomd.html#espressomd.lb.LBFluidWalberla" title="espressomd.lb.LBFluidWalberla"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBFluidWalberla</span></code></a> object can be substituted
with the <a class="reference internal" href="espressomd.html#espressomd.lb.LBFluidWalberlaGPU" title="espressomd.lb.LBFluidWalberlaGPU"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBFluidWalberlaGPU</span></code></a> object to switch from CPU based
to GPU based execution. For further
information on CUDA support see section <a class="reference internal" href="running.html#cuda-acceleration"><span class="std std-ref">CUDA acceleration</span></a>.</p>
<p>The following minimal example demonstrates how to use the GPU implementation
of the LBM in analogy to the example for the CPU given in section
<a class="reference internal" href="#setting-up-a-lb-fluid"><span class="std std-ref">Setting up a LB fluid</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
<span class="n">system</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">system</span><span class="o">.</span><span class="n">cell_system</span><span class="o">.</span><span class="n">skin</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="n">lbf</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">LBFluidWalberlaGPU</span><span class="p">(</span><span class="n">agrid</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kinematic_viscosity</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">lb</span> <span class="o">=</span> <span class="n">lbf</span>
<span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>The waLBerla library supports multi-GPU simulations.
Without a suitable CUDA-aware MPI library, multi-GPU simulations are slower
than single-GPU simulations, and would only be relevant for LB systems that
are too large to fit in the memory of a single GPU device.
Multi-GPU support in ESPResSo is an experimental feature whose API may change at any time.
It can be activated by invoking the following expression before the creation
of the first LB GPU instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">cuda_init_handle</span><span class="o">.</span><span class="n">call_method</span><span class="p">(</span><span class="s2">&quot;set_device_id_per_rank&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Due to padding, the memory footprint of the GPU fields is not a linear function
of the grid size. Instead, it is a step function of the size along the x-direction
of the rank-local LB domain.
For illustration, a local LB domain with dimensions 64x256x256 will take as
much VRAM as a domain with size 127x256x256 in single-precision mode.
As a rule of thumb, the VRAM in GiB per rank-local LB domain will be:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\label{eq:lj}
  f(n_x, n_y, n_z) =
    \begin{cases}
      \left\lceil n_x / 64 \right\rceil \cdot 64 \cdot n_y \cdot n_z \cdot 204 / 1024^3
      &amp; \text{(in single-precision)}\\
      \left\lceil n_x / 32 \right\rceil \cdot 32 \cdot n_y \cdot n_z \cdot 410 / 1024^3
      &amp; \text{(in double-precision)}
    \end{cases}\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(n_x\)</span>, <span class="math notranslate nohighlight">\(n_y\)</span>, <span class="math notranslate nohighlight">\(n_z\)</span> the LB domain size in agrid units, including the ghost layer.</p>
<p>Regarding communication between GPUs, for optimal performance the MPI Cartesian topology
should divide the z-direction first, the y-direction second, and the x-direction
last, i.e. ascending order of the integer factors. Please note the default MPI
Cartesian grid in ESPResSo is sorted in descending order of the integer factors,
and leads to poor performance. For illustration, a Cartesian grid with
shape <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">8]</span></code> yields 94% weak scaling efficiency,
shape <code class="docutils literal notranslate"><span class="pre">[8,</span> <span class="pre">1,</span> <span class="pre">1]</span></code> yields 90%,
shape <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">4]</span></code> yields 88%,
shape <code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">2,</span> <span class="pre">1]</span></code> yields 86%,
shape <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">2,</span> <span class="pre">2]</span></code> yields 81%.
This is assuming 1 GPU per CPU. Using more than 1 CPU per GPU or more
than 1 GPU per CPU can degrade weak scaling efficiency further.</p>
</section>
<section id="electrohydrodynamics">
<span id="id15"></span><h2><span class="section-number">13.8. </span>Electrohydrodynamics<a class="headerlink" href="#electrohydrodynamics" title="Link to this heading">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This needs the feature <code class="docutils literal notranslate"><span class="pre">LB_ELECTROHYDRODYNAMICS</span></code>.</p>
</div>
<p>If the feature is activated, the lattice-Boltzmann code can be
used to implicitly model surrounding salt ions in an external electric
field by having the charged particles create flow.</p>
<p>For that to work, you need to set the electrophoretic mobility
(multiplied by the external <span class="math notranslate nohighlight">\(E\)</span>-field) <span class="math notranslate nohighlight">\(\mu E\)</span> on the
particles that should be subject to the field. This effectively acts
as a velocity offset between the particle and the LB fluid.</p>
<p>For more information on this method and how it works, read the
publication <span id="id16">Hickey <em>et al.</em> [<a class="reference internal" href="bibliography.html#id58" title="Owen A. Hickey, Christian Holm, James L. Harden, and Gary W. Slater. Implicit method for simulating electrohydrodynamics of polyelectrolytes. Physical Review Letters, 105(14):148301, 2010. doi:10.1103/PhysRevLett.105.148301.">2010</a>]</span>.</p>
</section>
<section id="setting-up-boundary-conditions">
<span id="setting-up-lb-boundary-conditions"></span><h2><span class="section-number">13.9. </span>Setting up boundary conditions<a class="headerlink" href="#setting-up-boundary-conditions" title="Link to this heading">¶</a></h2>
<p>Currently, only the so-called “link-bounce-back” algorithm for boundary
nodes is available. This creates a boundary that is located
approximately midway between lattice nodes. With no-slip boundary conditions,
populations are reflected back. With slip velocities, the reflection is
followed by a velocity interpolation. This allows to create shear flow and
boundaries “moving” relative to each other.</p>
<p>Under the hood, a boundary field is added to the blockforest, which contains
pre-calculated information for the reflection and interpolation operations.</p>
<section id="per-node-boundary-conditions">
<span id="per-node-lb-boundary-conditions"></span><h3><span class="section-number">13.9.1. </span>Per-node boundary conditions<a class="headerlink" href="#per-node-boundary-conditions" title="Link to this heading">¶</a></h3>
<p>One can set (or update) the slip velocity of individual nodes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd.lb</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="n">system</span><span class="o">.</span><span class="n">cell_system</span><span class="o">.</span><span class="n">skin</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">system</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">lbf</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">LBFluidWalberla</span><span class="p">(</span><span class="n">agrid</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kinematic_viscosity</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">lb</span> <span class="o">=</span> <span class="n">lbf</span>
<span class="c1"># make one node a boundary node with a slip velocity</span>
<span class="n">lbf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">VelocityBounceBack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="c1"># update node for no-slip boundary conditions</span>
<span class="n">lbf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">VelocityBounceBack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="c1"># remove boundary conditions</span>
<span class="n">lbf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
</section>
<section id="shape-based-boundary-conditions">
<span id="shape-based-lb-boundary-conditions"></span><h3><span class="section-number">13.9.2. </span>Shape-based boundary conditions<a class="headerlink" href="#shape-based-boundary-conditions" title="Link to this heading">¶</a></h3>
<p>Adding a shape-based boundary is straightforward:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd.lb</span>
<span class="kn">import</span> <span class="nn">espressomd.shapes</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="n">system</span><span class="o">.</span><span class="n">cell_system</span><span class="o">.</span><span class="n">skin</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">system</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">lbf</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">lb</span><span class="o">.</span><span class="n">LBFluidWalberla</span><span class="p">(</span><span class="n">agrid</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kinematic_viscosity</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">lb</span> <span class="o">=</span> <span class="n">lbf</span>
<span class="c1"># set up shear flow between two sliding walls</span>
<span class="n">wall1</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">Wall</span><span class="p">(</span><span class="n">normal</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="n">dist</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">lbf</span><span class="o">.</span><span class="n">add_boundary_from_shape</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">wall1</span><span class="p">,</span> <span class="n">velocity</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
<span class="n">wall2</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">Wall</span><span class="p">(</span><span class="n">normal</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="n">dist</span><span class="o">=-</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">box_l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.5</span><span class="p">))</span>
<span class="n">lbf</span><span class="o">.</span><span class="n">add_boundary_from_shape</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">wall2</span><span class="p">,</span> <span class="n">velocity</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">velocity</span></code> argument is optional, in which case the no-slip boundary
conditions are used. For a position-dependent slip velocity, the argument
to <code class="docutils literal notranslate"><span class="pre">velocity</span></code> must be a 4D grid (the first three dimensions must match
the LB grid shape, the fourth dimension has size 3 for the velocity).</p>
<p>The LB boundaries use the same <a class="reference internal" href="espressomd.html#module-espressomd.shapes" title="espressomd.shapes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">shapes</span></code></a> objects to specify
their geometry as <a class="reference internal" href="espressomd.html#module-espressomd.constraints" title="espressomd.constraints"><code class="xref py py-mod docutils literal notranslate"><span class="pre">constraints</span></code></a> do for particles.
This allows the user to quickly set up a system with boundary conditions
that simultaneously act on the fluid and particles. For a complete
description of all available shapes, refer to <a class="reference internal" href="espressomd.html#module-espressomd.shapes" title="espressomd.shapes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">espressomd.shapes</span></code></a>.</p>
<p>When using shapes, keep in mind the lattice origin is offset by half a grid
size from the box origin. For illustration purposes, assuming <code class="docutils literal notranslate"><span class="pre">agrid=1</span></code>,
setting a wall constraint with <code class="docutils literal notranslate"><span class="pre">dist=1</span></code> and a normal vector pointing along
the x-axis will set all LB nodes in the left side of the box as boundary
nodes with thickness 1. The same outcome is obtained with <code class="docutils literal notranslate"><span class="pre">dist=1.49</span></code>,
but with <code class="docutils literal notranslate"><span class="pre">dist=1.51</span></code> the thickness will be 2.</p>
</section>
</section>
<section id="prototyping-new-lb-methods">
<span id="id17"></span><h2><span class="section-number">13.10. </span>Prototyping new LB methods<a class="headerlink" href="#prototyping-new-lb-methods" title="Link to this heading">¶</a></h2>
<p>Start by installing the code generator dependencies:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3<span class="w"> </span>-m<span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>-c<span class="w"> </span>requirements.txt<span class="w"> </span>numpy<span class="w"> </span>sympy<span class="w"> </span>lbmpy<span class="w"> </span>pystencils<span class="w"> </span>islpy
</pre></div>
</div>
<p>Next, edit the code generator script to configure new kernels, then execute it:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3<span class="w"> </span>maintainer/walberla_kernels/generate_lb_kernels.py
</pre></div>
</div>
<p>The script takes optional arguments to control the CPU or GPU architecture,
as well as the floating-point precision. The generated source code files need
to be written to <code class="file docutils literal notranslate"><span class="pre">src/walberla_bridge/src/lattice_boltzmann/generated_kernels/</span></code>.
These steps can be automated with the convenience shell functions documented in
<code class="file docutils literal notranslate"><span class="pre">maintainer/walberla_kernels/Readme.md</span></code>.
Edit the <code class="file docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> file in the destination folder to include the
new kernels in the build system.
Then, adapt <code class="file docutils literal notranslate"><span class="pre">src/walberla_bridge/src/lattice_boltzmann/LBWalberlaImpl.hpp</span></code>
to use the new LB kernels.</p>
<p>The current LB implementation uses the two-relaxation-time (TRT) LB method
with pull scheme and zero-centered <span id="id18">[<a class="reference internal" href="bibliography.html#id73" title="Frederik Hennig, Markus Holzer, and Ulrich Rüde. Advanced automatic code generation for multiple relaxation-time lattice Boltzmann methods. SIAM Journal on Scientific Computing, 45(4):C233–C254, 2023. doi:10.1137/22M1531348.">Hennig <em>et al.</em>, 2023</a>]</span> storage format.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.paraview.org/">https://www.paraview.org/</a></p>
</aside>
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://code.enthought.com/projects/mayavi/">http://code.enthought.com/projects/mayavi/</a></p>
</aside>
</aside>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">13. Lattice-Boltzmann</a><ul>
<li><a class="reference internal" href="#setting-up-a-lb-fluid">13.1. Setting up a LB fluid</a><ul>
<li><a class="reference internal" href="#performance-considerations">13.1.1. Performance considerations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#checkpointing">13.2. Checkpointing</a></li>
<li><a class="reference internal" href="#interpolating-velocities">13.3. Interpolating velocities</a></li>
<li><a class="reference internal" href="#coupling-lb-to-a-md-simulation">13.4. Coupling LB to a MD simulation</a><ul>
<li><a class="reference internal" href="#lb-and-lebc">13.4.1. LB and LEbc</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reading-and-setting-properties-of-single-lattice-nodes">13.5. Reading and setting properties of single lattice nodes</a></li>
<li><a class="reference internal" href="#vtk-output">13.6. VTK output</a></li>
<li><a class="reference internal" href="#choosing-between-the-gpu-and-cpu-implementations">13.7. Choosing between the GPU and CPU implementations</a></li>
<li><a class="reference internal" href="#electrohydrodynamics">13.8. Electrohydrodynamics</a></li>
<li><a class="reference internal" href="#setting-up-boundary-conditions">13.9. Setting up boundary conditions</a><ul>
<li><a class="reference internal" href="#per-node-boundary-conditions">13.9.1. Per-node boundary conditions</a></li>
<li><a class="reference internal" href="#shape-based-boundary-conditions">13.9.2. Shape-based boundary conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#prototyping-new-lb-methods">13.10. Prototyping new LB methods</a></li>
</ul>
</li>
</ul>

  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2023, The ESPResSo project.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>