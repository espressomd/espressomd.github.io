
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>1. Introduction &#8212; ESPResSo 4.2.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/blockquotes.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/toggleprompt.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Installation" href="installation.html" />
    <link rel="prev" title="ESPResSo documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="introduction">
<span id="id1"></span><h1><span class="section-number">1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p><em>ESPResSo</em> is a simulation package designed to perform Molecular Dynamics (MD) and
Monte Carlo (MC) simulations. It is meant to be a universal tool for
simulations of a variety of soft matter systems. It <a class="reference internal" href="installation.html#features"><span class="std std-ref">features</span></a> a
broad range of interaction potentials which opens up possibilities for
performing simulations using models with different levels of coarse-graining.
It also includes modern and efficient algorithms for treatment of
<a class="reference internal" href="electrostatics.html#electrostatics"><span class="std std-ref">Electrostatics</span></a> (P3M, MMM-type algorithms, constant potential
simulations, dielectric interfaces, …), hydrodynamic interactions
(<a class="reference internal" href="integration.html#dissipative-particle-dynamics-dpd"><span class="std std-ref">DPD</span></a>, <a class="reference internal" href="lb.html#lattice-boltzmann"><span class="std std-ref">Lattice-Boltzmann</span></a>),
and <a class="reference internal" href="magnetostatics.html#magnetostatics"><span class="std std-ref">magnetic interactions</span></a>, only
to name a few.  It is designed to exploit the capabilities of parallel
computational environments.  The program is being continuously extended to keep
the pace with current developments both in the algorithms and software.</p>
<p>The kernel of <em>ESPResSo</em> is written in C++ with computational efficiency in mind.
Interaction between the user and the simulation engine is provided via a
<em>Python scripting interface</em>. This enables setup of arbitrarily complex
systems, with simulation parameters that can be modified at runtime.</p>
<section id="guiding-principles">
<span id="id2"></span><h2><span class="section-number">1.1. </span>Guiding principles<a class="headerlink" href="#guiding-principles" title="Permalink to this headline">¶</a></h2>
<p><em>ESPResSo</em> is a tool for performing computer simulation and this user guide describes
how to use this tool. However, it should be borne in mind that being able to
operate a tool is not sufficient to obtain physically meaningful results. It is
always the responsibility of the user to understand the principles behind the
model, simulation and analysis methods he or she is using.</p>
<p>It is expected that the users of <em>ESPResSo</em> and readers of this user guide have a
thorough understanding of simulation methods and algorithms they are planning
to use. They should have passed a basic course on molecular simulations or read
one of the renown textbooks, e.g. <span id="id3">[<a class="reference internal" href="bibliography.html#id40" title="Daan Frenkel and Berend Smit. Understanding molecular simulation: From algorithms to applications. Academic Press, San Diego, 2nd edition, 2002. ISBN 978-0-12-267351-1. doi:10.1016/B978-0-12-267351-1.X5000-7.">Frenkel and Smit, 2002</a>]</span>. It is not necessary to
understand everything that is contained in <em>ESPResSo</em>, but it is inevitable to
understand all methods that you want to use. Using the program as a black box
without proper understanding of the background will most probably result in
wasted user and computer time with no useful output.</p>
<p>To enable future extensions, the functionality of the program is kept as
general as possible. It is modularized, so that extensions to some parts
of the program (e.g. implementing a new potential) can be done by modifying
or adding only a few files, leaving most of the code untouched.</p>
<p>Much emphasis is put on readability of the code. To cite a few examples,
hard-coded C-style for loops are generally avoided in favor of modern C++
range-based for loops or STL accumulators and algorithms, and output
parameters are often avoided by returning a <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code>. In addition,
vector algebra can be expressed in few lines of code thanks to the
<code class="docutils literal notranslate"><span class="pre">Utils::Vector</span></code> class that provides overloads for elementary operations,
the dot product, the cross product and operations with matrices.</p>
<p>Hand-in-hand with the extensibility and readability of the code comes the
flexibility of the whole program. On the one hand, it is provided by the
generalized functionality of its parts, avoiding highly specialized functions.
An example can be the implementation of the Generic Lennard-Jones potential
described in section <a class="reference internal" href="inter_non-bonded.html#generic-lennard-jones-interaction"><span class="std std-ref">Generic Lennard-Jones interaction</span></a> where the user
can change all available parameters. Where possible, default values are
avoided, providing the user with the possibility of choice. <em>ESPResSo</em> cannot be
aware whether your particles are representing atoms or billiard balls, so it
cannot check if the chosen parameters make sense and it is the user’s
responsibility to make sure they do. In fact, <em>ESPResSo</em> can be used to play
billiard (see sample script <code class="file docutils literal notranslate"><span class="pre">samples/billiard.py</span></code>)!</p>
<p>On the other hand, flexibility of <em>ESPResSo</em> stems from the employment of a scripting
language at the steering level. Apart from the ability to modify the simulation
and system parameters at runtime, many simple tasks which are not
computationally critical can be implemented at this level, without even
touching the C++ kernel. For example, simple problem-specific analysis routines
can be implemented in this way and made to interact with the simulation core.
Another example of the program’s flexibility is the possibility to integrate
system setup, simulation and analysis in one single control script. <em>ESPResSo</em>
provides commands to create particles and set up interactions between them.
Capping of forces helps prevent system blow-up when initially some particles
are placed on top of each other. Using the Python interface, one can simulate
the randomly set-up system with capped forces, interactively check whether it
is safe to remove the cap and switch on the full interactions and then perform
the actual productive simulation.</p>
</section>
<section id="basic-program-structure">
<span id="id4"></span><h2><span class="section-number">1.2. </span>Basic program structure<a class="headerlink" href="#basic-program-structure" title="Permalink to this headline">¶</a></h2>
<p>As already mentioned, <em>ESPResSo</em> consists of two components. The simulation engine is
written in C++ for the sake of computational efficiency. The steering or
control level is interfaced to the kernel via an interpreter of Python
scripting languages.</p>
<p>The kernel performs all computationally demanding tasks. Before all,
integration of Newton’s equations of motion, including calculation of energies
and forces. It also takes care of internal organization of data, storing the
data about particles, communication between different processors or cells of
the cell-system. The kernel is modularized so that basic functions are accessed
via a set of well-defined lean interfaces, hiding the details of the complex
numerical algorithms.</p>
<p>The scripting interface (Python) is used to setup the system (particles,
boundary conditions, interactions, …), control the simulation, run analysis,
and store and load results. The user has at hand the full readability and
functionality of the scripting language.  For instance, it is possible to use
the SciPy package for analysis and PyPlot for plotting. With a certain overhead
in efficiency, it can also be used to reject/accept new configurations in
combined MD/MC schemes.  In principle, any parameter which is accessible from
the scripting level can be changed at any moment of runtime. In this way
methods like thermodynamic integration become readily accessible.</p>
<p>The focus of the user guide is documenting the scripting interface, its
behavior and use in the simulation. It only describes certain technical details
of implementation which are necessary for understanding how the script
interface works. Technical documentation of the code and program structure is
contained in the <a class="reference external" href="https://github.com/espressomd/espresso/wiki">online wiki</a>.</p>
</section>
<section id="basic-python-simulation-script">
<span id="id5"></span><h2><span class="section-number">1.3. </span>Basic python simulation script<a class="headerlink" href="#basic-python-simulation-script" title="Permalink to this headline">¶</a></h2>
<p>In this section, a brief overview is given over the most important components
of the Python interface. Their usage is illustrated by short examples, which
can be put together to a demo script.</p>
<p class="rubric">Imports</p>
<p>As usual, the Python script starts by importing the necessary modules.  The
<em>ESPResSo</em> interface is contained in the <a class="reference internal" href="espressomd.html#module-espressomd" title="espressomd"><code class="xref py py-mod docutils literal notranslate"><span class="pre">espressomd</span></code></a> Python module, which needs to be
imported, before anything related can be done.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd</span>
</pre></div>
</div>
<p>This should be followed by further necessary imports of the example at hand:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">espressomd.interactions</span>
<span class="kn">import</span> <span class="nn">espressomd.electrostatics</span>
</pre></div>
</div>
<p class="rubric">espressomd.System</p>
<p>Access to the simulation system is provided via the <a class="reference internal" href="espressomd.html#espressomd.system.System" title="espressomd.system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> class. As a
first step, an instance of this class needs to be created.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">System</span><span class="p">(</span><span class="n">box_l</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that only one instance of the System class can be created due to
limitations in the simulation core. <a class="reference internal" href="system_setup.html#setting-global-variables"><span class="std std-ref">Properties of the System
class</span></a> are used to access the parameters
concerning the simulation system such as box geometry, time step or
<a class="reference internal" href="system_setup.html#cell-systems"><span class="std std-ref">cell-system</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;The box dimensions are </span><span class="si">{system.box_l}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">system</span><span class="o">.</span><span class="n">cell_system</span><span class="o">.</span><span class="n">skin</span> <span class="o">=</span> <span class="mf">0.4</span>
</pre></div>
</div>
<p class="rubric">Particles</p>
<p>The particles in the simulation are accessed via <code class="docutils literal notranslate"><span class="pre">system.part</span></code>, an instance of the
<a class="reference internal" href="espressomd.html#espressomd.particle_data.ParticleList" title="espressomd.particle_data.ParticleList"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleList</span></code></a> class. Use the <code class="docutils literal notranslate"><span class="pre">add</span></code> method to
<a class="reference internal" href="particles.html#adding-particles"><span class="std std-ref">create new particles</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">part1</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">part2</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The individual particles are represented by instances of <a class="reference internal" href="espressomd.html#espressomd.particle_data.ParticleHandle" title="espressomd.particle_data.ParticleHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleHandle</span></code></a> which, as
demonstrated in the example above, can be stored as Python variables (<code class="docutils literal notranslate"><span class="pre">part1</span></code> and <code class="docutils literal notranslate"><span class="pre">part2</span></code>).
The properties of the particle are implemented as Python properties and can be accessed and/or modified using
the respective <a class="reference internal" href="espressomd.html#espressomd.particle_data.ParticleHandle" title="espressomd.particle_data.ParticleHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleHandle</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">part2</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
<span class="go">[1.0, 1.0, 2.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">part2</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">part2</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
<span class="go">[0.2, 2.0, 0.0]</span>
</pre></div>
</div>
<p>It is also possible to <a class="reference internal" href="particles.html#iterating-over-particles-and-pairs-of-particles"><span class="std std-ref">loop</span></a> over all particles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Particle pos </span><span class="si">{p.pos}</span><span class="s2">, type </span><span class="si">{p.type}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Internally, each particle is automatically assigned a unique numerical id by <em>ESPResSo</em>.
Note that in principle it is possible to explicitly set this particle id (if not in use already) on particle creation.
Using the id, the respective particle can be accessed from the particle list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">by_id</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">by_id</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
<span class="go">[1.0, 1.0, 2.0]</span>
</pre></div>
</div>
<p>For larger simulation setups, explicit handling of numerical ids can quickly
become confusing and is thus error-prone. We therefore highly recommend using
<a class="reference internal" href="espressomd.html#espressomd.particle_data.ParticleHandle" title="espressomd.particle_data.ParticleHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleHandle</span></code></a> instead wherever possible.</p>
<p><a class="reference internal" href="particles.html#interacting-with-groups-of-particles"><span class="std std-ref">Properties of all particles</span></a>
can be accessed via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">positions</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">pos</span>
</pre></div>
</div>
<p class="rubric">Interactions</p>
<p>In <em>ESPResSo</em>, interactions between particles usually fall in three categories:</p>
<ul class="simple">
<li><p><a class="reference internal" href="inter_non-bonded.html#non-bonded-interactions"><span class="std std-ref">Non-bonded interactions</span></a> are short-ranged interactions between <em>all</em>
pairs of particles of specified types. An example is the
Lennard-Jones interaction mimicking overlap repulsion and van-der-Waals attraction.</p></li>
<li><p><a class="reference internal" href="inter_bonded.html#bonded-interactions"><span class="std std-ref">Bonded interactions</span></a> act only between two specific particles. An
example is the harmonic bond between adjacent particles in a polymer
chain.</p></li>
<li><p>Long-range interactions act between all particles with specific
properties in the entire system. An example is the <a class="reference internal" href="electrostatics.html#electrostatics"><span class="std std-ref">Coulomb
interaction</span></a>.</p></li>
</ul>
<p class="rubric">Non-bonded interaction</p>
<p>Non-bonded interactions are represented as subclasses of
<a class="reference internal" href="espressomd.html#espressomd.interactions.NonBondedInteraction" title="espressomd.interactions.NonBondedInteraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonBondedInteraction</span></code></a>, e.g.
<a class="reference internal" href="espressomd.html#espressomd.interactions.LennardJonesInteraction" title="espressomd.interactions.LennardJonesInteraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">LennardJonesInteraction</span></code></a>.
Instances of these classes for a given pair of particle types are accessed via
the non_bonded_inter attribute of the System class. This sets up a Lennard-Jones
interaction between all particles of type 0 with the given parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">non_bonded_inter</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lennard_jones</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Bonded interaction</p>
<p>Next, we add a pair of particles with a different type to later add
a <a class="reference internal" href="inter_bonded.html#harmonic-bond"><span class="std std-ref">harmonic bond</span></a> between them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">part1</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">part2</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>To set up a bonded interaction, first an instance of the appropriate
class is created with the desired parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">harmonic</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">interactions</span><span class="o">.</span><span class="n">HarmonicBond</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">r_0</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, the bonded interaction is registered in the simulation core
by adding the instance to <a class="reference internal" href="espressomd.html#espressomd.system.System.bonded_inter" title="espressomd.system.System.bonded_inter"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bonded_inter</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">bonded_inter</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">harmonic</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, the bond can be added to particles using the <a class="reference internal" href="espressomd.html#espressomd.particle_data.ParticleHandle.add_bond" title="espressomd.particle_data.ParticleHandle.add_bond"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_bond()</span></code></a>
method of <a class="reference internal" href="espressomd.html#espressomd.particle_data.ParticleHandle" title="espressomd.particle_data.ParticleHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleHandle</span></code></a> with the instance of the bond class and the
instance of the partner particle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">part1</span><span class="o">.</span><span class="n">add_bond</span><span class="p">((</span><span class="n">harmonic</span><span class="p">,</span> <span class="n">part2</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">Charges</p>
<p>Now we demonstrate how to setup a pair of charged particles treated by the P3M
electrostatics solver. We start by adding the particles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cation</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">anion</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Long-range interactions and other methods that might be mutually exclusive
are treated as so-called <em>actors</em>. They are used by first creating an instance
of the desired actor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p3m</span> <span class="o">=</span> <span class="n">espressomd</span><span class="o">.</span><span class="n">electrostatics</span><span class="o">.</span><span class="n">P3M</span><span class="p">(</span><span class="n">accuracy</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">prefactor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>and then adding it to the system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Tuning p3m ...&quot;</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">actors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p3m</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Integration</p>
<p>So far we just <em>added</em> particles and interactions, but did not propagate the
system. This is done by the <em>integrator</em>.  It uses by default the velocity
Verlet algorithm and is already created by the system class. To perform an
integration step, just execute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Usually, the system is propagated for a number of steps in a loop alongside
with some analysis. In this last snippet, the different energy contributions
of the system are printed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_configs</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_configs</span><span class="p">):</span>
    <span class="n">system</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">energy</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;System time: </span><span class="si">{system.time}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Energy of the LJ interaction: </span><span class="si">{energy[&#39;non_bonded&#39;]}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Energy of the harmonic bond: </span><span class="si">{energy[&#39;bonded&#39;]}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Energy of the Coulomb interaction: </span><span class="si">{energy[&#39;coulomb&#39;]}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="tutorials">
<span id="id6"></span><h2><span class="section-number">1.4. </span>Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this headline">¶</a></h2>
<p>There are a number of tutorials that introduce the use of <em>ESPResSo</em> for different
physical systems. You can also find the tutorials and related scripts in the
directory <code class="file docutils literal notranslate"><span class="pre">/doc/tutorials</span></code>.
They are executed with the <code class="docutils literal notranslate"><span class="pre">ipypresso</span></code> script.</p>
<p>The following tutorials are available:</p>
<ul class="simple">
<li><p><code class="file docutils literal notranslate"><span class="pre">lennard_jones</span></code>: Modelling of a single-component and a two-component Lennard-Jones liquid.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">visualization</span></code>: Using the online visualizers of <em>ESPResSo</em>.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">error_analysis</span></code>: Statistical analysis of simulation results.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">charged_system</span></code>: Modelling of ion condensation around a charged rod.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">ferrofluid</span></code>: Modelling a colloidal suspension of magnetic particles.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">lattice_boltzmann</span></code>: Simulations including hydrodynamic interactions using the lattice-Boltzmann method.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">raspberry_electrophoresis</span></code>: Extended objects in a lattice-Boltzmann fluid, raspberry particles.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">active_matter</span></code>: Modelling of self-propelling particles.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">electrokinetics</span></code>: Modelling electrokinetics together with hydrodynamic interactions.</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">constant_pH</span></code>: Modelling the titration of a weak acid using the constant pH method</p></li>
</ul>
<p>The executed notebooks with solutions and plots are periodically deployed
online to the <a class="reference external" href="https://espressomd.github.io/tutorials.html">GitHub Pages</a>.</p>
</section>
<section id="sample-scripts">
<span id="id7"></span><h2><span class="section-number">1.5. </span>Sample scripts<a class="headerlink" href="#sample-scripts" title="Permalink to this headline">¶</a></h2>
<p>Several scripts that can serve as usage examples can be found in the
directory <code class="file docutils literal notranslate"><span class="pre">/samples</span></code>.
They are executed with the <code class="docutils literal notranslate"><span class="pre">pypresso</span></code> script.</p>
<p>The following samples are available:</p>
<ul>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">billiard.py</span></code></dt><dd><p><em>ESPResSo</em> 8Ball billiards game.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">chamber_game.py</span></code></dt><dd><p>Game based on Maxwell’s demon, a thought experiment used to teach statistical
thermodynamics. The user has to scoop particles from a chamber and guide them
to another chamber through a channel with the help of a snake controlled by a
gamepad or the keyboard. The particle imbalance between chambers creates
a pressure gradient that makes it harder to move particles to the chamber
with an excess of particles.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">constraints.py</span></code></dt><dd><p>Confine a polymer between two slabs and check that it cannot escape
them during the entire simulation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">dancing.py</span></code></dt><dd><p>Stokesian Dynamics simulation of particle sedimentation.
Reproduce the trajectory in Figure 5b from <span id="id8">[<a class="reference internal" href="bibliography.html#id36" title="L. Durlofsky, J. F. Brady, and G. Bossis. Dynamic simulation of hydrodynamically interacting particles. Journal of Fluid Mechanics, 180:21–49, 1987. doi:10.1017/S002211208700171X.">Durlofsky <em>et al.</em>, 1987</a>]</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">diffusion_coefficient.py</span></code></dt><dd><p>Compare the diffusion coefficient of a single thermalized particle obtained
from the particle’s mean square displacement and the auto correlation
function of its velocity to the expected value. Uses the
Observables/Correlators framework.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">dpd.py</span></code></dt><dd><p>Set up a DPD fluid and calculate pressure as a function of the
varying density. The fluid is thermalized using a DPD thermostat.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">drude_bmimpf6.py</span></code></dt><dd><p>Particle polarization with cold Drude oscillators on a coarse-grained
simulation of the ionic liquid BMIM PF6.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">ekboundaries.py</span></code></dt><dd><p>Set up an electrokinetics (LB) fluid confined between charged walls.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">electrophoresis.py</span></code></dt><dd><p>Simulate electrophoresis of a linear polymer using the P3M electrostatics solver.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">espresso_logo.py</span></code></dt><dd><p>Build the <em>ESPResSo</em> logo with particles.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">grand_canonical.py</span></code></dt><dd><p>Perform a grand canonical simulation of a system in contact
with a salt reservoir while maintaining a constant chemical potential.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">h5md.py</span></code></dt><dd><p>Write <em>ESPResSo</em> trajectories in the H5MD format. See <a class="reference internal" href="io.html#writing-h5md-files"><span class="std std-ref">Writing H5MD-files</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">h5md_trajectory.py</span></code></dt><dd><p>Write <em>ESPResSo</em> trajectories in the H5MD format with a Lees-Edwards offset,
aperiodic boundaries and a fluctuating box size. Read the trajectory and
reconstruct the unfolded positions. See <a class="reference internal" href="io.html#writing-h5md-files"><span class="std std-ref">Writing H5MD-files</span></a> for details.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">immersed_boundary/sampleImmersedBoundary.py</span></code></dt><dd><p>Simulate the motion of a spherical red blood cell-like particle advected
in a planar Poiseuille flow, with or without volume conservation. For more
details, see <a class="reference internal" href="advanced_methods.html#immersed-boundary-method-for-soft-elastic-objects"><span class="std std-ref">Immersed Boundary Method for soft elastic objects</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">lb_profile.py</span></code></dt><dd><p>Simulate the flow of a lattice-Boltzmann fluid past a cylinder,
obtain the velocity profile in polar coordinates and compare it
to the analytical solution.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">lbf.py</span></code></dt><dd><p>Set up a lattice-Boltzmann fluid and apply an external force density on it.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="file docutils literal notranslate"><span class="pre">lj_liquid.py</span></code></dt><dd><p>Simulate a Lennard-Jones fluid maintained at a fixed temperature
by a Langevin thermostat. Shows the basic features of how to:</p>
<ul class="simple">
<li><p>set up system parameters, particles and interactions.</p></li>
<li><p>warm up and integrate.</p></li>
<li><p>write parameters, configurations and observables to files.</p></li>
</ul>
<p>The particles in the system are of two types: type 0 and type 1.
Type 0 particles interact with each other via a repulsive WCA
interaction. Type 1 particles neither interact with themselves
nor with type 0 particles.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">lj_liquid_distribution.py</span></code></dt><dd><p>Set up a Lennard-Jones fluid maintained at a fixed temperature by a
Langevin thermostat. The particles in the system are of two types:
type 0 and type 1. Type 0 particles interact with each other via a
repulsive WCA interaction. Type 1 particles neither interact with
themselves nor with type 0 particles. The distribution of minimum
distances between particles of type 0 and type 1 is recorded with
<a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.distribution" title="espressomd.analyze.Analysis.distribution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distribution()</span></code></a>.
See <a class="reference internal" href="analysis.html#particle-distribution"><span class="std std-ref">Particle distribution</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">lj_liquid_structurefactor.py</span></code></dt><dd><p>Set up a Lennard-Jones fluid maintained at a fixed temperature by a
Langevin thermostat. The particles in the system are of two types:
type 0 and type 1. Type 0 particles interact with each other via a
repulsive WCA interaction. Type 1 particles neither interact with
themselves nor with type 0 particles. The spherically averaged
structure factor of particles of type 0 and type 1 is calculated
with <a class="reference internal" href="espressomd.html#espressomd.analyze.Analysis.structure_factor" title="espressomd.analyze.Analysis.structure_factor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">structure_factor()</span></code></a>.
See <a class="reference internal" href="analysis.html#structure-factor"><span class="std std-ref">Structure factor</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">load_checkpoint.py</span></code></dt><dd><p>Basic usage of the checkpointing feature. Show how to load the state of:</p>
<ul class="simple">
<li><p>custom user variables.</p></li>
<li><p>non-bonded interactions.</p></li>
<li><p>particles.</p></li>
<li><p>P3M parameters.</p></li>
<li><p>thermostat.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">MDAnalysisIntegration.py</span></code></dt><dd><p>Show how to expose configuration to <code class="docutils literal notranslate"><span class="pre">MDAnalysis</span></code> at run time. The
functions of <code class="docutils literal notranslate"><span class="pre">MDAnalysis</span></code> can be used to perform some analysis or
convert the frame to other formats (CHARMM, GROMACS, …). For more
details, see <a class="reference internal" href="io.html#writing-various-formats-using-mdanalysis"><span class="std std-ref">Writing various formats using MDAnalysis</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">minimal-charged-particles.py</span></code></dt><dd><p>Simulate an equal number of positively and negatively charged particles
using the P3M solver. The system is maintained at a constant temperature
using a Langevin thermostat.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">minimal-diamond.py</span></code></dt><dd><p>Set up a diamond-structured polymer network.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">minimal-polymer.py</span></code></dt><dd><p>Set up a linear polymer.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">object_in_fluid/motivation.py</span></code></dt><dd><p>Simulate the motion of flexible red blood cells in a lattice-Boltzmann fluid
with solid obstacles. For more details, see <a class="reference internal" href="advanced_methods.html#object-in-fluid"><span class="std std-ref">Object-in-fluid</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">observables_correlators.py</span></code></dt><dd><p>Measure mean square displacements using the Observables/Correlators framework.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">p3m.py</span></code></dt><dd><p>Simulate a Lennard-Jones liquid with charges. The P3M method is used to
calculate electrostatic interactions.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">reaction_ensemble_complex_reaction.py</span></code></dt><dd><p>Guide for the reaction ensemble. The modeled reaction is
<span class="math notranslate nohighlight">\(2\mathrm{A} + 3\mathrm{B} \leftrightarrow 4\mathrm{C} + 1\mathrm{D} + 3\mathrm{E}\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">reaction_methods.py</span></code></dt><dd><p>Guide for the reaction ensemble and the constant pH ensemble. The modeled
reaction is <span class="math notranslate nohighlight">\(\mathrm{AH} \leftrightarrow \mathrm{A}^- + \mathrm{H}^+\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">rigid_body.py</span></code></dt><dd><p>Demonstrates the construction of a rigid object by means of the
<code class="docutils literal notranslate"><span class="pre">VIRTUAL_SITES_RELATIVE</span></code> feature.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">save_checkpoint.py</span></code></dt><dd><p>Basic usage of the checkpointing feature. Show how to write the state of:</p>
<ul class="simple">
<li><p>custom user variables.</p></li>
<li><p>non-bonded interactions.</p></li>
<li><p>particles.</p></li>
<li><p>P3M parameters.</p></li>
<li><p>thermostat.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">slice_input.py</span></code></dt><dd><p>Illustrate how particles of interest can be accessed via slicing.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_bonded.py</span></code></dt><dd><p>Visualize the simulation of a linear polymer.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_cellsystem.py</span></code></dt><dd><p>Visualize the system cells and MPI domains. Run <em>ESPResSo</em> in parallel
to color particles by node. With OpenMPI, this can be achieved using
<code class="docutils literal notranslate"><span class="pre">mpiexec</span> <span class="pre">-n</span> <span class="pre">4</span> <span class="pre">./pypresso</span> <span class="pre">../samples/visualization_cellsystem.py</span></code>.
Set property <code class="docutils literal notranslate"><span class="pre">system.cell_system.node_grid</span> <span class="pre">=</span> <span class="pre">[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> (with <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">*</span> <span class="pre">j</span> <span class="pre">*</span> <span class="pre">k</span></code>
equal to the number of MPI ranks) to change the way the cellsystem is
partitioned. Only the domain of MPI rank 0 will be shown in wireframe.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_charged.py</span></code></dt><dd><p>Visualize a simulation with a pool of particles with various charges,
LJ parameters and masses.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_constraints.py</span></code></dt><dd><p>Visualize shape-based constraints interacting with a Lennard-Jones gas.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_elc.py</span></code></dt><dd><p>Visualize charged particles confined between two plates of a capacitor with
a potential difference. The system is periodic in the <em>xy</em>-plane but has a gap
in the <em>z</em>-direction. The ELC method subtracts the electrostatic contribution
from the periodic images in the <em>z</em>-direction. The system total charge is zero.
For more details, see <a class="reference internal" href="electrostatics.html#electrostatic-layer-correction-elc"><span class="std std-ref">Electrostatic Layer Correction (ELC)</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_interactive.py</span></code></dt><dd><p>Visualize a simulation box where the particles can be repositioned via the
mouse and timed callbacks, and the temperature of the thermostat can be
changed via the keyboard.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_lbboundaries.py</span></code></dt><dd><p>Visualize lattice-Boltzmann boundary nodes.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_ljliquid.py</span></code></dt><dd><p>Visualize a Lennard-Jones liquid with live plotting via matplotlib.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_npt.py</span></code></dt><dd><p>Visualize particle dumbbells in the NpT ensemble (constant temperature,
constant pressure, variable volume).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">visualization_poiseuille.py</span></code></dt><dd><p>Visualize the Poiseuille flow in a lattice-Boltzmann fluid with an
external force applied.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">widom_insertion.py</span></code></dt><dd><p>Measure the excess chemical potential of a charged WCA fluid via Widom’s
insertion method.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="on-units">
<span id="id9"></span><h2><span class="section-number">1.6. </span>On units<a class="headerlink" href="#on-units" title="Permalink to this headline">¶</a></h2>
<p>What is probably one of the most confusing subjects for beginners of <em>ESPResSo</em> is,
that <em>ESPResSo</em> does not predefine any units. While most MD programs specify a set
of units, like, for example, that all lengths are measured in Ångström
or nanometers, times are measured in nano- or picoseconds and energies
are measured in <span class="math notranslate nohighlight">\(\mathrm{kJ/mol}\)</span>, <em>ESPResSo</em> does not do so.</p>
<p>Instead, the length-, time- and energy scales can be freely chosen by
the user. Once these three scales are fixed, all remaining units are
derived from these three basic choices.</p>
<p>The probably most important choice is the length scale. A length of
<span class="math notranslate nohighlight">\(1.0\)</span> can mean a nanometer, an Ångström, or a kilometer -
depending on the physical system, that the user has in mind when he
writes his <em>ESPResSo</em>-script. When creating particles that are intended to
represent a specific type of atoms, one will probably use a length scale
of Ångström. This would mean, that the parameter <span class="math notranslate nohighlight">\(\sigma\)</span> of the
Lennard-Jones interaction between two atoms would be set to twice the
van-der-Waals radius of the atom in Ångström. Alternatively, one could
set <span class="math notranslate nohighlight">\(\sigma\)</span> to <span class="math notranslate nohighlight">\(2.0\)</span> and measure all lengths in multiples
of the van-der-Waals radius. When simulation colloidal particles, which
are usually of micrometer size, one will choose their diameter (or
radius) as basic length scale, which is much larger than the Ångström
scale used in atomistic simulations.</p>
<p>The second choice to be made is the energy scale. One can for example
choose to set the Lennard-Jones parameter <span class="math notranslate nohighlight">\(\epsilon\)</span> to the energy
in <span class="math notranslate nohighlight">\(\mathrm{kJ/mol}\)</span>. Then all energies will be measured in that
unit. Alternatively, one can choose to set it to <span class="math notranslate nohighlight">\(1.0\)</span> and measure
everything in multiples of the van-der-Waals binding energy of the
respective particles.</p>
<p>The final choice is the time (or mass) scale. By default, <em>ESPResSo</em> uses a reduced
mass of 1 for all particles, so that the mass unit is simply the mass of one particle.
Combined with the energy and length scale, this is sufficient to derive
the resulting time scale:</p>
<div class="math notranslate nohighlight">
\[[\mathrm{time}] = [\mathrm{length}]\sqrt{\frac{[\mathrm{mass}]}{[\mathrm{energy}]}}\]</div>
<p>This means, that if you measure lengths in Ångström, energies in
<span class="math notranslate nohighlight">\(k_B T\)</span> at 300K and masses in 39.95u, then your time scale is
<span class="math notranslate nohighlight">\(\mathring{A} \sqrt{39.95u / k_B T} = 0.40\,\mathrm{ps}\)</span>.</p>
<p>On the other hand, if you want a particular time scale, then the mass
scale can be derived from the time, energy and length scales as</p>
<div class="math notranslate nohighlight">
\[[\mathrm{mass}] = [\mathrm{energy}]\frac{[\mathrm{time}]^2}{[\mathrm{length}]^2}.\]</div>
<p>By activating the feature <code class="docutils literal notranslate"><span class="pre">MASS</span></code>, you can specify particle masses in
the chosen unit system.</p>
<p>A special note is due regarding the temperature, which is coupled to the
energy scale by Boltzmann’s constant. However, since <em>ESPResSo</em> does not enforce a
particular unit system, we also don’t know the numerical value of the
Boltzmann constant in the current unit system. Therefore, when
specifying the temperature of a thermostat, you actually do not define
the temperature, but the value of the thermal energy <span class="math notranslate nohighlight">\(k_B T\)</span> in
the current unit system. For example, if you measure energy in units of
<span class="math notranslate nohighlight">\(\mathrm{kJ/mol}\)</span> and your real temperature should be 300K, then
you need to set the thermostat’s effective temperature to
<span class="math notranslate nohighlight">\(k_B 300\, K \mathrm{mol / kJ} = 2.494\)</span>.</p>
<p>As long as one remains within the same unit system throughout the whole
<em>ESPResSo</em>-script, there should be no problems.</p>
</section>
<section id="available-simulation-methods">
<span id="id10"></span><h2><span class="section-number">1.7. </span>Available simulation methods<a class="headerlink" href="#available-simulation-methods" title="Permalink to this headline">¶</a></h2>
<p><em>ESPResSo</em> provides a number of useful methods. The following table shows the
various methods as well as their status. The table distinguishes between
the state of the development of a certain feature and the state of its
use. We distinguish between five levels:</p>
<dl class="simple">
<dt><strong>Core</strong></dt><dd><p>means that the method is part of the core of <em>ESPResSo</em>, and that it is
extensively developed and used by many people.</p>
</dd>
<dt><strong>Good</strong></dt><dd><p>means that the method is developed and used by independent people
from different groups.</p>
</dd>
<dt><strong>Group</strong></dt><dd><p>means that the method is developed and used in one group.</p>
</dd>
<dt><strong>Single</strong></dt><dd><p>means that the method is developed and used by one person only.</p>
</dd>
<dt><strong>None</strong></dt><dd><p>means that the method is developed and used by nobody.</p>
</dd>
<dt><strong>Experimental</strong></dt><dd><p>means that the method might have side effects.</p>
</dd>
</dl>
<p>In the “Tested” column, we note whether there is an integration test for the method.</p>
<p>If you believe that the status of a certain method is wrong, please
report so to the developers using the instructions in <a class="reference internal" href="contributing.html#contributing"><span class="std std-ref">Contributing</span></a>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 37%" />
<col style="width: 28%" />
<col style="width: 21%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Feature</strong></p></th>
<th class="head"><p><strong>Development Status</strong></p></th>
<th class="head"><p><strong>Usage Status</strong></p></th>
<th class="head"><p><strong>Tested</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="4"><p><strong>Integrators</strong>, <strong>Thermostats</strong>, <strong>Barostats</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Velocity-Verlet Integrator</p></td>
<td><p>Core</p></td>
<td><p>Core</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Langevin Thermostat</p></td>
<td><p>Core</p></td>
<td><p>Core</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Isotropic NpT</p></td>
<td><p>Experimental</p></td>
<td><p>None</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Quaternion Integrator</p></td>
<td><p>Core</p></td>
<td><p>Good</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Stokesian Dynamics</p></td>
<td><p>Single</p></td>
<td><p>None</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td colspan="4"><p><strong>Interactions</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Short-range Interactions</p></td>
<td><p>Core</p></td>
<td><p>Core</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Constraints</p></td>
<td><p>Core</p></td>
<td><p>Core</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Relative Virtual Sites</p></td>
<td><p>Good</p></td>
<td><p>Good</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>RATTLE Rigid Bonds</p></td>
<td><p>Single</p></td>
<td><p>Group</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Gay–Berne Interaction</p></td>
<td><p>Experimental</p></td>
<td><p>Experimental</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td colspan="4"><p><strong>Coulomb Interaction</strong></p></td>
</tr>
<tr class="row-odd"><td><p>P3M</p></td>
<td><p>Core</p></td>
<td><p>Core</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>P3M on GPU</p></td>
<td><p>Single</p></td>
<td><p>Single</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Dipolar P3M</p></td>
<td><p>Group</p></td>
<td><p>Good</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>MMM1D</p></td>
<td><p>Single</p></td>
<td><p>Good</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>MMM1D on GPU</p></td>
<td><p>Single</p></td>
<td><p>Single</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>ELC</p></td>
<td><p>Good</p></td>
<td><p>Good</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>ICC*</p></td>
<td><p>Group</p></td>
<td><p>Group</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td colspan="4"><p><strong>Hydrodynamic Interaction</strong></p></td>
</tr>
<tr class="row-odd"><td><p>Lattice-Boltzmann</p></td>
<td><p>Core</p></td>
<td><p>Core</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Lattice-Boltzmann on GPU</p></td>
<td><p>Group</p></td>
<td><p>Core</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td colspan="4"><p><strong>Input/Output</strong></p></td>
</tr>
<tr class="row-even"><td><p>VTF output</p></td>
<td><p>Core</p></td>
<td><p>Core</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>VTK output</p></td>
<td><p>Group</p></td>
<td><p>Group</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>Checkpointing</p></td>
<td><p>Experimental</p></td>
<td><p>Experimental</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td colspan="4"><p><strong>Visualization</strong></p></td>
</tr>
<tr class="row-even"><td><p>OpenGL visualizer</p></td>
<td><p>Good</p></td>
<td><p>Good</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td colspan="4"><p><strong>Miscellaneous</strong></p></td>
</tr>
<tr class="row-even"><td><p>Electrokinetics</p></td>
<td><p>Group</p></td>
<td><p>Group</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Collision Detection</p></td>
<td><p>Group</p></td>
<td><p>Group</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Reaction Ensemble</p></td>
<td><p>Group</p></td>
<td><p>Group</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Constant pH Method</p></td>
<td><p>Group</p></td>
<td><p>Group</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Object-in-fluid</p></td>
<td><p>Group</p></td>
<td><p>Group</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Immersed boundary method</p></td>
<td><p>Group</p></td>
<td><p>Group</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>DPD</p></td>
<td><p>Single</p></td>
<td><p>Good</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>DPD Thermostat</p></td>
<td><p>Single</p></td>
<td><p>Good</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>
</section>
<section id="software-releases">
<span id="id11"></span><h2><span class="section-number">1.8. </span>Software releases<a class="headerlink" href="#software-releases" title="Permalink to this headline">¶</a></h2>
<p><em>ESPResSo</em> releases use the following versioning scheme: <code class="docutils literal notranslate"><span class="pre">major.minor.patch_level</span></code>.
New features are introduced in major and minor releases, while bugfix releases
only patch bugs without adding or removing features. Since the <code class="docutils literal notranslate"><span class="pre">patch_level</span></code>
doesn’t affect the capabilities of the software, it’s common to refer to
releases simply as <code class="docutils literal notranslate"><span class="pre">major.minor</span></code>.</p>
<p>New users should always choose the latest release. When opting for an
older release, we recommend using the latest bugfix release from that
line (for example 4.0.2 instead of 4.0), unless you need to capture the
behavior of bugs for reproducibility reasons. When filing bug reports
or citing <em>ESPResSo</em>, the version should always be mentioned. See
our policies on <a class="reference internal" href="contributing.html#contributing"><span class="std std-ref">bug reports</span></a> and
<a class="reference internal" href="#how-to-cite-espresso"><span class="std std-ref">citing the software</span></a> for more details.</p>
<p>Releases from 4.0 onward can be found on
<a class="reference external" href="https://github.com/espressomd/espresso/releases">GitHub</a>.
Older releases from 2.1 to 3.3 can be found in
<a class="reference external" href="http://download.savannah.gnu.org/releases/espressomd/">GNU Savannah</a>.
See our policy on <a class="reference internal" href="#intended-interface-compatibility-between-espresso-versions"><span class="std std-ref">API backward compatibility</span></a>
if you need more details.</p>
<section id="release-workflow">
<span id="id12"></span><h3><span class="section-number">1.8.1. </span>Release workflow<a class="headerlink" href="#release-workflow" title="Permalink to this headline">¶</a></h3>
<p>Major and minor releases are branched from the development branch <code class="docutils literal notranslate"><span class="pre">python</span></code>.
When a version <code class="docutils literal notranslate"><span class="pre">X.Y.0</span></code> is released, the <code class="docutils literal notranslate"><span class="pre">python</span></code> branch is copied
to a new branch named <code class="docutils literal notranslate"><span class="pre">X.Y</span></code>, at which point the <code class="docutils literal notranslate"><span class="pre">python</span></code> branch is ready
to accept contributions for the <code class="docutils literal notranslate"><span class="pre">X.Y+1.0</span></code> release. The <code class="docutils literal notranslate"><span class="pre">X.Y</span></code> branch
still gets bugfix releases <code class="docutils literal notranslate"><span class="pre">X.Y.1</span></code>, <code class="docutils literal notranslate"><span class="pre">X.Y.2</span></code>, …, for several months.</p>
<p><a class="reference external" href="https://github.com/espressomd/espresso/milestones">GitHub milestones</a>
track the progress of each release. They can give you an idea of the changes
in future releases, although it’s more convenient to follow the live release
notes in the <a class="reference external" href="https://github.com/espressomd/espresso/wiki">wiki</a> (listed
under “Planned releases” in the side bar). These notes are updated monthly.
Most users will only be interested in the live release notes of the
planned bugfix release for the version of <em>ESPResSo</em> they’re using.</p>
<p>If you’re actively developing code for <em>ESPResSo</em>, you might also be interested in
the summaries of the <a class="reference external" href="https://github.com/espressomd/espresso/wiki/Offline-Espresso-meeting">ESPResSo meetings</a>,
where the core team discusses plans for future releases and feature freezes.</p>
</section>
<section id="intended-interface-compatibility-between-es-versions">
<span id="intended-interface-compatibility-between-espresso-versions"></span><h3><span class="section-number">1.8.2. </span>Intended interface compatibility between <em>ESPResSo</em> versions<a class="headerlink" href="#intended-interface-compatibility-between-es-versions" title="Permalink to this headline">¶</a></h3>
<p>With regards to the stability of the Python interface, we have the following
guidelines:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">patch_level</span></code>: The Python interface will not change if only the
<code class="docutils literal notranslate"><span class="pre">patch_level</span></code> number is different. Example: 4.0.0 <span class="math notranslate nohighlight">\(\to\)</span> 4.0.1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">minor</span></code>: There will be no silent interface changes between two versions
with different minor numbers, i.e. a simulation script will not silently
produce different results with the new version. The interface can, however,
be extended. In important cases, the interface can change in such a way
that using the old interface produces a clear error message and the
simulation is terminated. Example: 4.0.2 <span class="math notranslate nohighlight">\(\to\)</span> 4.1.0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">major</span></code>: No guarantees are made for a transition between major versions.
Example: 4.1.2 <span class="math notranslate nohighlight">\(\to\)</span> 5.0.</p></li>
<li><p>No guarantees are made with regards to the development branch on GitHub.</p></li>
<li><p>No guarantees are made with respect to the C++ bindings in the simulation core.</p></li>
</ul>
</section>
<section id="how-to-cite-es">
<span id="how-to-cite-espresso"></span><h3><span class="section-number">1.8.3. </span>How to cite <em>ESPResSo</em><a class="headerlink" href="#how-to-cite-es" title="Permalink to this headline">¶</a></h3>
<p>Please cite <span id="id13">Weik <em>et al.</em> [<a class="reference internal" href="bibliography.html#id99" title="Florian Weik, Rudolf Weeber, Kai Szuttor, Konrad Breitsprecher, Joost de Graaf, Michael Kuron, Jonas Landsgesell, Henri Menke, David Sean, and Christian Holm. ESPResSo 4.0 – an extensible software package for simulating soft matter systems. The European Physical Journal Special Topics, 227(14):1789–1816, 2019. doi:10.1140/epjst/e2019-800186-9.">2019</a>]</span> (BibTeX key <code class="docutils literal notranslate"><span class="pre">weik19a</span></code> in <code class="file docutils literal notranslate"><span class="pre">doc/bibliography.bib</span></code>)
for <em>ESPResSo</em> 4.0 and later, or both <span id="id14">Arnold <em>et al.</em> [<a class="reference internal" href="bibliography.html#id12" title="A. Arnold, O. Lenz, S. Kesselheim, R. Weeber, F. Fahrenberger, D. Röhm, P. Košovan, and C. Holm. ESPResSo 3.1 — molecular dynamics software for coarse-grained models. In M. Griebel and M. A. Schweitzer, editors, Meshfree Methods for Partial Differential Equations VI, volume 89 of Lecture Notes in Computational Science and Engineering, pages 1–23. Springer Berlin Heidelberg, 2013. doi:10.1007/978-3-642-32979-1_1.">2013</a>]</span> and <span id="id15">Limbach <em>et al.</em> [<a class="reference internal" href="bibliography.html#id62" title="H. J. Limbach, A. Arnold, B. A. Mann, and C. Holm. ESPResSo – an extensible simulation package for research on soft matter systems. Computer Physics Communications, 174(9):704–727, 2006. doi:10.1016/j.cpc.2005.10.005.">2006</a>]</span>
(BibTeX keys <code class="docutils literal notranslate"><span class="pre">arnold13a</span></code> and <code class="docutils literal notranslate"><span class="pre">limbach06a</span></code> in <code class="file docutils literal notranslate"><span class="pre">doc/bibliography.bib</span></code>)
for <em>ESPResSo</em> 2.0 to 3.3. To find the version number, use the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./pypresso -c <span class="s2">&quot;import espressomd.version;print(espressomd.version.friendly())&quot;</span>
</pre></div>
</div>
<p>A number of algorithms in <em>ESPResSo</em> are fairly advanced and unique to <em>ESPResSo</em>.
The authors of these contributions kindly ask you to cite the relevant
publications, using the BibTeX entries indicated in this user guide.</p>
<p>A complete citation would look like this:</p>
<blockquote>
<div><p>Simulations were carried out with ESPResSo 4.2[24] using the ICC*
algorithm[25].</p>
<div class="line-block">
<div class="line">____________</div>
</div>
<div class="line-block">
<div class="line">[24] F. Weik, R. Weeber, K. Szuttor <em>et al.</em> ESPResSo 4.0 – an
extensible software package for simulating soft matter systems.
<em>Eur. Phys. J. Spec. Top.</em> <strong>227</strong>, 1789–1816 (2019).
doi:<a class="reference external" href="https://doi.org/10.1140/epjst/e2019-800186-9">10.1140/epjst/e2019-800186-9</a>.</div>
<div class="line">[25] C. Tyagi, M. Süzen, M. Sega <em>et al.</em> An iterative, fast,
linear-scaling method for computing induced charges on arbitrary
dielectric boundaries. <em>J. Chem. Phys.</em> <strong>132</strong>, 154112 (2010).
doi:<a class="reference external" href="https://doi.org/10.1063/1.3376011">10.1063/1.3376011</a>.</div>
</div>
</div></blockquote>
<p>You may also provide the patch level, when relevant. If you developed code
for <em>ESPResSo</em> and made it available in a publicly accessible repository, you
should consider providing the corresponding URL, for example in a footnote:</p>
<blockquote>
<div><p>The method was implemented for ESPResSo 4.2.1[24] and the source code is
available online<sup>note 1</sup>.</p>
<div class="line-block">
<div class="line">____________</div>
</div>
<div class="line-block">
<div class="line"><sup>note 1</sup> <a class="reference external" href="https://github.com/username/espresso/tree/implemented-algorithm">https://github.com/username/espresso/tree/implemented-algorithm</a></div>
</div>
<div class="line-block">
<div class="line">[24] F. Weik, R. Weeber, K. Szuttor <em>et al.</em> ESPResSo 4.0 – an
extensible software package for simulating soft matter systems.
<em>Eur. Phys. J. Spec. Top.</em> <strong>227</strong>, 1789–1816 (2019).
doi:<a class="reference external" href="https://doi.org/10.1140/epjst/e2019-800186-9">10.1140/epjst/e2019-800186-9</a>.</div>
</div>
</div></blockquote>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. Introduction</a><ul>
<li><a class="reference internal" href="#guiding-principles">1.1. Guiding principles</a></li>
<li><a class="reference internal" href="#basic-program-structure">1.2. Basic program structure</a></li>
<li><a class="reference internal" href="#basic-python-simulation-script">1.3. Basic python simulation script</a></li>
<li><a class="reference internal" href="#tutorials">1.4. Tutorials</a></li>
<li><a class="reference internal" href="#sample-scripts">1.5. Sample scripts</a></li>
<li><a class="reference internal" href="#on-units">1.6. On units</a></li>
<li><a class="reference internal" href="#available-simulation-methods">1.7. Available simulation methods</a></li>
<li><a class="reference internal" href="#software-releases">1.8. Software releases</a><ul>
<li><a class="reference internal" href="#release-workflow">1.8.1. Release workflow</a></li>
<li><a class="reference internal" href="#intended-interface-compatibility-between-es-versions">1.8.2. Intended interface compatibility between <em>ESPResSo</em> versions</a></li>
<li><a class="reference internal" href="#how-to-cite-es">1.8.3. How to cite <em>ESPResSo</em></a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2023, The ESPResSo project.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>